#!/usr/bin/env python3

import argparse
import csv
import sys
from pathlib import Path

# This dictionary maps the expected CSV header names to the command line options
# for 'label-printer.py'. This makes the script flexible; you can easily add
# or change mappings here without altering the core logic.
HEADER_TO_OPTION_MAP = {
    'list': '--list',
    'count': '--count',
    'date': '--date',
    'message': '--message',
    'border_message': '--border-message',
    'side_border': '--side-border',
    'image': '--image',
    'show_date': '--show-date',
    'preview_only': '--preview-only',
}

# A set of options that are flags (they don't take a value after them).
FLAG_OPTIONS = {'--list', '--show-date', '--preview-only'}


def parse_arguments():
    """Parses command line arguments for this script."""
    parser = argparse.ArgumentParser(
        description="Generate a Windows Batch file to run 'label-printer.py' based on a CSV file.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        '-f', '--file',
        required=True,
        type=Path,
        help="Path to the input CSV file containing label data."
    )
    parser.add_argument(
        '-o', '--output',
        default='run_labels.bat',  # <<< CHANGED to .bat
        help="Name of the output batch script to be generated (default: run_labels.bat)."
    )
    return parser.parse_args()


def create_batch_script(csv_path: Path, output_script_name: str):
    """
    Reads the CSV file and generates a Windows Batch script with commands.

    Args:
        csv_path (Path): The path to the input CSV file.
        output_script_name (str): The filename for the generated batch script.
    """
    if not csv_path.is_file():
        print(f"Error: The file '{csv_path}' was not found.", file=sys.stderr)
        sys.exit(1)

    # --- Batch file commands ---
    batch_commands = [
        "@echo off",
        ":: This script was auto-generated by generate-label-script.py",
        ":: It runs a series of commands to print labels.",
        ""
    ]

    try:
        with open(csv_path, mode='r', encoding='utf-8', newline='') as infile:
            reader = csv.DictReader(infile)
            
            for i, row in enumerate(reader, 1):
                # On Windows, 'python' or the 'py' launcher is typically used.
                command_parts = ["python", "label-printer.py"]

                for header in reader.fieldnames:
                    normalized_header = header.lower().replace(' ', '_')
                    if normalized_header not in HEADER_TO_OPTION_MAP:
                        continue
                    
                    value = row[header].strip()
                    if not value:
                        continue

                    option = HEADER_TO_OPTION_MAP[normalized_header]
                    if option in FLAG_OPTIONS:
                        if value.lower() in ['true', '1', 'yes', 'y']:
                            command_parts.append(option)
                    else:
                        command_parts.append(option)
                        command_parts.append(f'"{value}"')
                
                if len(command_parts) > 2:
                    batch_commands.append(f':: --- Label command for row {i} ---')
                    batch_commands.append(f'echo Executing command for row {i}...')
                    batch_commands.append(" ".join(command_parts))
                    batch_commands.append("")

    except FileNotFoundError:
        print(f"Error: The file '{csv_path}' was not found.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An error occurred while processing the CSV file: {e}", file=sys.stderr)
        sys.exit(1)

    # Write the collected commands to the output batch file.
    # No need for newline='\n' as we want the Windows default.
    with open(output_script_name, 'w', encoding='utf-8') as outfile:
        outfile.write("\n".join(batch_commands))
        outfile.write("\n\necho All label commands executed successfully.\n")
        outfile.write("pause\n") # Add pause to see the final message before window closes

    # No chmod needed for Windows batch files.
    print(f"âœ… Success! Windows Batch file '{output_script_name}' created.")
    print("You can now run it by double-clicking it or by typing its name in the command prompt.")


def main():
    """Main function to run the script."""
    args = parse_arguments()
    create_batch_script(args.file, args.output)


if __name__ == "__main__":
    main()