#!/usr/bin/env python3

import argparse
import csv
import sys
from pathlib import Path

# This dictionary maps the expected CSV header names to the command line options
# for 'label-printer.py'. This makes the script flexible; you can easily add
# or change mappings here without altering the core logic.
HEADER_TO_OPTION_MAP = {
    'list': '--list',
    'count': '--count',
    'date': '--date',
    'message': '--message',
    'border_message': '--border-message',
    'side_border': '--side-border',
    'image': '--image',
    'show_date': '--show-date',
    'preview_only': '--preview-only',
}

# A set of options that are flags (they don't take a value after them).
# This helps the script know whether to add a value from the CSV or just the flag.
FLAG_OPTIONS = {'--list', '--show-date', '--preview-only'}


def parse_arguments():
    """Parses command line arguments for this script."""
    parser = argparse.ArgumentParser(
        description="Generate a bash script to run 'label-printer.py' based on a CSV file.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        '-f', '--file',
        required=True,
        type=Path,
        help="Path to the input CSV file containing label data."
    )
    parser.add_argument(
        '-o', '--output',
        default='run_label_printer.sh',
        help="Name of the output bash script to be generated (default: run_label_printer.sh)."
    )
    return parser.parse_args()


def create_bash_script(csv_path: Path, output_script_name: str):
    """
    Reads the CSV file and generates a bash script with commands.

    Args:
        csv_path (Path): The path to the input CSV file.
        output_script_name (str): The filename for the generated bash script.
    """
    if not csv_path.is_file():
        print(f"Error: The file '{csv_path}' was not found.", file=sys.stderr)
        sys.exit(1)

    bash_commands = [
        "#!/bin/bash",
        "# This script was auto-generated by generate-label-script.py",
        "# It runs a series of commands to print labels.",
        "set -e  # Exit immediately if a command exits with a non-zero status.",
        ""
    ]

    try:
        with open(csv_path, mode='r', encoding='utf-8', newline='') as infile:
            # Using csv.DictReader is ideal as it handles headers automatically
            # and provides each row as a dictionary.
            reader = csv.DictReader(infile)
            
            for i, row in enumerate(reader, 1):
                command_parts = ["python", "label-printer.py"]

                # Iterate through the headers found in the CSV file
                for header in reader.fieldnames:
                    # Normalize header to lower case and with underscores
                    normalized_header = header.lower().replace(' ', '_')
                    
                    # Skip if the header is not one we recognize
                    if normalized_header not in HEADER_TO_OPTION_MAP:
                        continue
                    
                    value = row[header].strip()
                    
                    # --- CRITICAL LOGIC ---
                    # If a field for a column is empty on a particular row,
                    # skip adding the option altogether.
                    if not value:
                        continue

                    option = HEADER_TO_OPTION_MAP[normalized_header]

                    if option in FLAG_OPTIONS:
                        # For flags, a "truthy" value (like 'true', '1', 'yes')
                        # in the CSV means we add the flag.
                        if value.lower() in ['true', '1', 'yes', 'y']:
                            command_parts.append(option)
                    else:
                        # For options that take arguments, add the option and its value.
                        # We quote the value to handle spaces and special characters.
                        command_parts.append(option)
                        command_parts.append(f'"{value}"')
                
                # Only add a command to the script if it has more than the base parts
                if len(command_parts) > 2:
                    # Add a comment for clarity in the bash script
                    bash_commands.append(f"# --- Label command for row {i} ---")
                    bash_commands.append(f'echo "Executing command for row {i}..."')
                    bash_commands.append(" ".join(command_parts))
                    bash_commands.append("") # Add a blank line for readability

    except FileNotFoundError:
        print(f"Error: The file '{csv_path}' was not found.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An error occurred while processing the CSV file: {e}", file=sys.stderr)
        sys.exit(1)

    # Write the collected commands to the output bash file
    with open(output_script_name, 'w', encoding='utf-8') as outfile:
        outfile.write("\n".join(bash_commands))
        outfile.write("\n\necho 'All label commands executed successfully.'\n")

    # Make the script executable for the user
    try:
        output_path = Path(output_script_name)
        output_path.chmod(0o755)
        print(f"âœ… Success! Bash script '{output_script_name}' created and made executable.")
    except Exception as e:
        print(f"Could not make the script executable. You may need to run 'chmod +x {output_script_name}' manually.", file=sys.stderr)
        print(f"Reason: {e}", file=sys.stderr)


def main():
    """Main function to run the script."""
    args = parse_arguments()
    create_bash_script(args.file, args.output)


if __name__ == "__main__":
    main()