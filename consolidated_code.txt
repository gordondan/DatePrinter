
# ============================================================
# --- .HTML FILES ---
# ============================================================

// --- Start of content from: www\index.html ---

<!doctype html>
<meta charset="utf-8" />
<title>Pi Label Printer</title>
<style>
  :root { --ok:#0a7d29; --err:#b00020; --muted:#555; --bg:#f6f8fa; --focus:#0366d6; --focus-bg:#e8f4fd; }
  body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; margin: 24px; }
  h1 { margin: 0 0 8px; }
  .muted { color: var(--muted); margin-bottom: 18px; }
  label { display: block; margin: 8px 0 4px; }
  input[type=text], input[type=number], input[type=date] { width: 360px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
  input[type=text]:focus, input[type=number]:focus, input[type=date]:focus { outline: 2px solid var(--focus); border-color: var(--focus); }
  input[type=checkbox] { margin-right: 8px; }
  input[type=checkbox]:focus { outline: 2px solid var(--focus); }
  .row { margin-bottom: 12px; }
  button { padding: 10px 14px; border: 1px solid var(--focus); background: var(--focus); color: white; border-radius: 4px; cursor: pointer; }
  button:hover, button:focus { background: #025aa5; outline: 2px solid var(--focus); }
  button:disabled { background: #ccc; border-color: #ccc; cursor: not-allowed; }
  pre { background: var(--bg); padding: 12px; border-radius: 6px; overflow: auto; max-width: 900px; }
  .status { margin-top: 12px; font-weight: 600; }
  .ok { color: var(--ok); }
  .err { color: var(--err); }
  .links { margin: 16px 0 24px; }
  a { color: var(--focus); text-decoration: none; padding: 4px 8px; border-radius: 4px; }
  a:hover, a:focus { text-decoration: underline; background: var(--focus-bg); outline: 2px solid var(--focus); }
  #previewImage { border: 1px solid #ddd; max-width: 600px; display: none; }
  #timing { margin-top: 8px; color: var(--muted); }
  .navigation-help { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 8px 12px; border-radius: 4px; font-size: 11px; z-index: 1000; }
</style>
<h1>Pi Label Printer</h1>
<div class="muted">Submit options to run pi-label-printer.py on the server, or use the quick link to print today's date.</div>

<div class="links">
  <a href="/app/date">Print today's date (quick)</a>
  &nbsp;•&nbsp;
  <a href="/api/pi-label/options" target="_blank" rel="noopener">API options (JSON)</a>
  &nbsp;•&nbsp;
  <a href="/app">Home</a>
  &nbsp;•&nbsp;
  <a href="/app/pi-label">Form only</a>
  &nbsp;•&nbsp;
  <a href="/recent">Recent</a>
  </div>

<form id="labelForm">
  <div class="row"><label>Count</label><input type="number" name="count" value="1" min="1" required /></div>
  <div class="row"><label>Date</label><input type="date" name="date" /></div>
  <div class="row"><label>Message</label><input type="text" name="message" placeholder="Main label message" /></div>
  <div class="row"><label>Border Message</label><input type="text" name="border_message" placeholder="Top/Bottom border text" /></div>
  <div class="row"><label>Side Border</label><input type="text" name="side_border" placeholder="Left/Right border text" /></div>
  <div class="row"><label>Image Path</label><input type="text" name="image" placeholder="/path/to/image.png" /></div>
  <div class="row"><label><input type="checkbox" name="show_date" /> Show date on label</label></div>
  <div class="row"><label><input type="checkbox" name="preview_only" /> Preview only (no print)</label></div>
  <button type="submit" id="submitBtn">Submit</button>
  <span id="status" class="status"></span>
</form>

<h2>Result</h2>
<pre id="result"></pre>

<h2>Preview</h2>
<img id="previewImage" alt="label preview" />
<div id="timing"></div>

<div class="navigation-help">
  Tab: Navigate \u2022 Enter: Submit \u2022 Space: Toggle Checkboxes
</div>

<script>
const form = document.getElementById('labelForm');
const submitBtn = document.getElementById('submitBtn');
const statusEl = document.getElementById('status');
const previewImg = document.getElementById('previewImage');
const timingEl = document.getElementById('timing');
form.addEventListener('submit', async (e) => {
  e.preventDefault();
  const data = new FormData(form);
  const payload = {
    list: data.get('list') === 'on',
    count: data.get('count') ? Number(data.get('count')) : undefined,
    date: data.get('date') || undefined,
    message: data.get('message') || undefined,
    border_message: data.get('border_message') || undefined,
    side_border: data.get('side_border') || undefined,
    image: data.get('image') || undefined,
    show_date: data.get('show_date') === 'on',
    preview_only: data.get('preview_only') === 'on',
  };
  statusEl.textContent = '';
  statusEl.className = 'status';
  timingEl.textContent = '';
  previewImg.style.display = 'none';
  submitBtn.disabled = true;
  submitBtn.textContent = 'Submitting...';
  const res = await fetch('/api/pi-label/print', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  let body;
  try { body = await res.json(); } catch (_) { body = await res.text(); }
  document.getElementById('result').textContent = typeof body === 'string' ? body : JSON.stringify(body, null, 2);
  statusEl.textContent = res.ok ? 'OK: Print command executed' : 'Error: See details below';
  statusEl.className = 'status ' + (res.ok ? 'ok' : 'err');

  // Display elapsed time if provided
  if (typeof body === 'object' && body && typeof body.elapsed_sec === 'number') {
    timingEl.textContent = `Elapsed: ${body.elapsed_sec.toFixed(3)}s`;
  }

  // Show preview image if URL provided
  if (typeof body === 'object' && body && body.preview_url) {
    previewImg.src = body.preview_url;
    previewImg.style.display = 'block';
  }

  submitBtn.disabled = false;
  submitBtn.textContent = 'Submit';
});
</script>



// --- End of content from: www\index.html ---

// --- Start of content from: www\recent.html ---

<!doctype html>
<meta charset="utf-8" />
<title>Recent Labels</title>
<style>
  :root { --ok:#0a7d29; --err:#b00020; --muted:#555; --bg:#f6f8fa; --focus:#0366d6; --focus-bg:#e8f4fd; }
  body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; margin: 24px; }
  h1 { margin: 0 0 12px; }
  .muted { color: var(--muted); margin-bottom: 18px; }
  .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; }
  .card { border: 1px solid #ddd; border-radius: 6px; padding: 0; background: #fff; cursor: pointer; transition: all 0.2s ease; position: relative; }
  .card:hover, .card:focus { border-color: var(--focus); background: var(--focus-bg); }
  .card:focus { outline: 2px solid var(--focus); outline-offset: 2px; }
  .card.selected { border-color: var(--focus); background: var(--focus-bg); box-shadow: 0 0 0 3px rgba(3, 102, 214, 0.3); }
  .card-content { padding: 12px; }
  .card img { width: 100%; height: auto; border: 1px solid #eee; pointer-events: none; }
  .meta { font-size: 12px; color: var(--muted); margin: 8px 0; pointer-events: none; }
  .delete-btn { background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; font-size: 12px; cursor: pointer; margin-top: 8px; width: 100%; }
  .delete-btn:hover, .delete-btn:focus { background: #c82333; outline: 2px solid var(--focus); }
  .status { margin-top: 4px; font-size: 12px; }
  .ok { color: var(--ok); }
  .err { color: var(--err); }
  .navigation-help { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.8); color: white; padding: 8px 12px; border-radius: 4px; font-size: 11px; z-index: 1000; }
  .home-link { display: inline-block; padding: 8px 12px; background: var(--focus); color: white; text-decoration: none; border-radius: 4px; margin-bottom: 12px; }
  .home-link:hover, .home-link:focus { background: #025aa5; color: white; outline: 2px solid var(--focus); }
</style>
<h1>Recent Labels</h1>
<div class="muted">Most recent previews from logs/. Click Reprint to send the label again.</div>
<div class="row" style="margin-bottom:12px;">
  <a href="/app" class="home-link" id="homeLink">Home</a>
</div>
<div id="container" class="grid"></div>
<div class="navigation-help">
  Arrow Keys: Navigate • Enter: Reprint • Delete: Remove • Tab: Next Element • Home: Return to main page
</div>
<script>
async function fetchRecent() {
  const res = await fetch('/api/recent');
  if (!res.ok) return [];
  const data = await res.json();
  return data.items || [];
}

async function reprint(path, statusEl) {
  statusEl.textContent = 'Reprinting…';
  statusEl.className = 'status';
  const res = await fetch('/api/reprint', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ path })
  });
  let body;
  try { body = await res.json(); } catch { body = { error: 'Invalid response' }; }
  if (res.ok && body.ok) {
    statusEl.textContent = `OK (elapsed ${body.elapsed_sec.toFixed(3)}s)`;
    statusEl.className = 'status ok';
  } else {
    statusEl.textContent = `Error: ${body.error || 'Unknown error'}`;
    statusEl.className = 'status err';
  }
}

async function deleteItem(path, statusEl, cardEl) {
  statusEl.textContent = 'Deleting…';
  statusEl.className = 'status';
  const res = await fetch('/api/delete', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ path })
  });
  let body;
  try { body = await res.json(); } catch { body = { error: 'Invalid response' }; }
  if (res.ok && body.ok) {
    statusEl.textContent = 'Deleted';
    statusEl.className = 'status ok';
    // remove the card after a short delay
    setTimeout(() => cardEl.remove(), 300);
  } else {
    statusEl.textContent = `Error: ${body.error || 'Unknown error'}`;
    statusEl.className = 'status err';
  }
}

let selectedIndex = -1;
let cards = [];

function render(items) {
  const c = document.getElementById('container');
  c.innerHTML = '';
  cards = [];
  
  for (let i = 0; i < items.length; i++) {
    const it = items[i];
    const card = document.createElement('div');
    card.className = 'card';
    card.tabIndex = 0;
    card.dataset.index = i;
    card.dataset.path = it.path;
    
    const cardContent = document.createElement('div');
    cardContent.className = 'card-content';
    
    const img = document.createElement('img');
    img.src = it.image_url;
    img.alt = 'preview';
    
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.textContent = `${it.mtime_iso} • ${it.size} bytes`;
    
    const delBtn = document.createElement('button');
    delBtn.className = 'delete-btn';
    delBtn.textContent = 'Delete';
    delBtn.tabIndex = -1;
    
    const status = document.createElement('div');
    status.className = 'status';
    
    // Make entire card clickable for reprint
    card.onclick = (e) => {
      if (e.target === delBtn) return; // Don't reprint if delete button was clicked
      reprint(it.path, status);
    };
    
    card.onkeydown = (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        e.stopPropagation();
        reprint(it.path, status);
      }
    };
    
    delBtn.onclick = (e) => {
      e.stopPropagation();
      deleteItem(it.path, status, card);
    };
    
    card.onfocus = () => {
      selectedIndex = i;
      updateSelection();
    };
    
    cardContent.appendChild(img);
    cardContent.appendChild(meta);
    cardContent.appendChild(delBtn);
    card.appendChild(cardContent);
    card.appendChild(status);
    c.appendChild(card);
    cards.push(card);
  }
  
  // Set initial selection to first card if any exist
  if (cards.length > 0) {
    selectedIndex = 0;
    updateSelection();
    cards[0].focus();
  }
}

function updateSelection() {
  cards.forEach((card, i) => {
    card.classList.toggle('selected', i === selectedIndex);
  });
}

function navigate(direction) {
  if (cards.length === 0) return;
  
  const oldIndex = selectedIndex;
  if (direction === 'up') {
    selectedIndex = Math.max(0, selectedIndex - Math.ceil(Math.sqrt(cards.length)));
  } else if (direction === 'down') {
    selectedIndex = Math.min(cards.length - 1, selectedIndex + Math.ceil(Math.sqrt(cards.length)));
  } else if (direction === 'left') {
    selectedIndex = Math.max(0, selectedIndex - 1);
  } else if (direction === 'right') {
    selectedIndex = Math.min(cards.length - 1, selectedIndex + 1);
  }
  
  if (oldIndex !== selectedIndex) {
    updateSelection();
    cards[selectedIndex].focus();
  }
}

function handleKeyPress(e) {
  if (cards.length === 0) return;
  
  switch(e.key) {
    case 'ArrowUp':
      e.preventDefault();
      navigate('up');
      break;
    case 'ArrowDown':
      e.preventDefault();
      navigate('down');
      break;
    case 'ArrowLeft':
      e.preventDefault();
      navigate('left');
      break;
    case 'ArrowRight':
      e.preventDefault();
      navigate('right');
      break;
    case 'Enter':
      e.preventDefault();
      e.stopPropagation();
      if (selectedIndex >= 0 && selectedIndex < cards.length) {
        const card = cards[selectedIndex];
        const path = card.dataset.path;
        const status = card.querySelector('.status');
        reprint(path, status);
      }
      break;
    case 'Delete':
    case 'Backspace':
      e.preventDefault();
      e.stopPropagation();
      if (selectedIndex >= 0 && selectedIndex < cards.length) {
        const card = cards[selectedIndex];
        const path = card.dataset.path;
        const status = card.querySelector('.status');
        deleteItem(path, status, card);
      }
      break;
    case 'Home':
      e.preventDefault();
      e.stopPropagation();
      document.getElementById('homeLink').click();
      break;
  }
}

document.addEventListener('keydown', handleKeyPress);

(async function init() {
  const items = await fetchRecent();
  render(items);
})();
</script>


// --- End of content from: www\recent.html ---


# ============================================================
# --- .PY FILES ---
# ============================================================

# --- Start of content from: find_rw402b.py ---

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Find a Munbyn/Beeprt RW402B over BLE with Bleak.
- Scans for devices whose name contains "rw402b", "munbyn", or "beeprt"
- Prints MAC, RSSI (if available), and name
- Optional: probe GATT to see if common write/notify UUIDs are present

Usage:
  ./find_rw402b.py                 # quick 4s scan
  ./find_rw402b.py --timeout 8     # longer scan
  ./find_rw402b.py --probe         # also probe strongest candidate
  ./find_rw402b.py --addr AA:BB:CC:DD:EE:FF --probe   # skip scan; probe specific MAC
"""

import asyncio
import argparse
from typing import Optional, Tuple, List

from bleak import BleakScanner, BleakClient
from bleak.backends.device import BLEDevice

# Common RW402B write/notify candidates
WRITE_CANDIDATES = [
    "49535343-8841-43f4-a8d4-ecbe34729bb3",  # SILABS RX (write)
    "0000fff2-0000-1000-8000-00805f9b34fb",  # FFF2 (write)
]
NOTIFY_CANDIDATES = [
    "49535343-1e4d-4bd9-ba61-23c647249616",  # SILABS TX (notify)
    "0000fff1-0000-1000-8000-00805f9b34fb",  # FFF1 (notify)
]

def looks_like_rw402b(name: Optional[str]) -> bool:
    if not name:
        return False
    n = name.lower()
    return ("rw402b" in n) or ("munbyn" in n) or ("beeprt" in n)

def get_rssi(dev: BLEDevice) -> Optional[int]:
    """Try to obtain RSSI across Bleak/BlueZ versions."""
    # 1) Some versions expose BLEDevice.rssi directly
    rssi = getattr(dev, "rssi", None)
    if isinstance(rssi, int):
        return rssi

    # 2) Sometimes in dev.details as dicts
    det = getattr(dev, "details", None)
    if isinstance(det, dict):
        # BlueZ often nests under "props" -> "RSSI"
        props = det.get("props") if isinstance(det.get("props"), dict) else None
        if props and isinstance(props.get("RSSI"), int):
            return props["RSSI"]
        # direct key
        if isinstance(det.get("RSSI"), int):
            return det["RSSI"]

    # 3) Some backends use advertised_data
    adv = getattr(dev, "advertisement_data", None)
    if adv is not None:
        adv_rssi = getattr(adv, "rssi", None)
        if isinstance(adv_rssi, int):
            return adv_rssi

    return None

async def scan(timeout: float) -> List[Tuple[BLEDevice, int]]:
    print(f"Scanning for {timeout:.1f}s…")
    devices = await BleakScanner.discover(timeout=timeout)
    hits: List[Tuple[BLEDevice, int]] = []

    for d in devices:
        rssi_val = get_rssi(d)
        rssi_str = f"{rssi_val:4d}" if isinstance(rssi_val, int) else "   ?"
        tag = " <- likely RW402B" if looks_like_rw402b(d.name) else ""
        print(f"{d.address:17s}  RSSI={rssi_str}  Name={d.name}{tag}")
        if looks_like_rw402b(d.name):
            hits.append((d, rssi_val if isinstance(rssi_val, int) else -999))
    return hits

async def probe_characteristics(addr: str) -> bool:
    print(f"\nProbing GATT on {addr} …")
    try:
        async with BleakClient(addr, timeout=10) as client:
            svcs = await client.get_services()
            found_write = []
            found_notify = []
            for s in svcs:
                for c in s.characteristics:
                    props = set(c.properties or [])
                    cu = c.uuid.lower()
                    if cu in [u.lower() for u in WRITE_CANDIDATES] and (
                        "write" in props or "write-without-response" in props
                    ):
                        found_write.append((c.uuid, sorted(props)))
                    if cu in [u.lower() for u in NOTIFY_CANDIDATES] and ("notify" in props):
                        found_notify.append((c.uuid, sorted(props)))

            if not found_write:
                print("No expected WRITE characteristics found. (We can still try both candidates when printing.)")
            else:
                print("Write characteristic(s) found:")
                for u, p in found_write:
                    print(f"  {u}  props={p}")

            if found_notify:
                print("Notify characteristic(s) found:")
                for u, p in found_notify:
                    print(f"  {u}  props={p}")
            else:
                print("No expected NOTIFY characteristics found (optional).")

            return True
    except Exception as e:
        print(f"Probe failed: {e}")
        return False

async def main():
    ap = argparse.ArgumentParser(description="Find Munbyn RW402B via BLE (Bleak).")
    ap.add_argument("--timeout", type=float, default=4.0, help="Scan time in seconds (default: 4.0)")
    ap.add_argument("--probe", action="store_true", help="After scan, probe the strongest RW402B hit for write/notify")
    ap.add_argument("--addr", help="Skip scan and directly probe this MAC")
    args = ap.parse_args()

    if args.addr:
        await probe_characteristics(args.addr)
        return

    hits = await scan(args.timeout)
    if not hits:
        print("\nNo obvious RW402B/Munbyn devices found.")
        print("Tips: increase --timeout, press Feed to wake the printer, move closer, or ensure no phone/app is connected.")
        return

    best_dev, best_rssi = max(hits, key=lambda t: t[1])
    rssi_str = "?" if best_rssi == -999 else str(best_rssi)
    print(f"\nLikely target: {best_dev.address}  (Name={best_dev.name}, RSSI={rssi_str})")

    if args.probe:
        await probe_characteristics(best_dev.address)

if __name__ == "__main__":
    asyncio.run(main())


# --- End of content from: find_rw402b.py ---

# --- Start of content from: logger.py ---

#!/usr/bin/env python3
"""
Logging module for label printer applications.
Creates timestamped log directories and handles log file management.
"""

import os
import shutil
from datetime import datetime
from pathlib import Path


class LabelPrinterLogger:
    """Logger for label printer operations."""
    
    def __init__(self, base_dir="logs", auto_create=True):
        """
        Initialize the logger.
        
        Args:
            base_dir: Base directory for logs (default: "logs")
            auto_create: Automatically create log directory structure
        """
        self.base_dir = Path(base_dir)
        self.current_log_dir = None
        self.log_file_path = None
        
        if auto_create:
            self.create_log_session()
    
    def create_log_session(self):
        """Create a new log session with timestamped directory."""
        now = datetime.now()
        year = now.strftime('%Y')
        month = now.strftime('%B')
        day = now.strftime('%B %d')
        time_str = now.strftime('%I-%M-%S %p')  # "03-30-45 PM"
        
        self.current_log_dir = self.base_dir / year / month / day / "runs" / time_str
        self.current_log_dir.mkdir(parents=True, exist_ok=True)
        
        self.log_file_path = self.current_log_dir / "log.txt"
        
        # Write initial log entry
        self.log(f"=== Label Printer Log Session Started ===")
        self.log(f"Timestamp: {now.strftime('%Y-%m-%d %H:%M:%S')}")
        self.log(f"Log directory: {self.current_log_dir}")
        self.log("")
        
        return self.current_log_dir
    
    def log(self, message):
        """
        Write a message to the log file.
        
        Args:
            message: Message to log
        """
        if not self.log_file_path:
            self.create_log_session()
        
        timestamp = datetime.now().strftime('%H:%M:%S')
        log_entry = f"[{timestamp}] {message}"
        
        try:
            with open(self.log_file_path, 'a', encoding='utf-8') as f:
                f.write(log_entry + '\n')
                f.flush()  # Ensure immediate write
        except Exception as e:
            print(f"Warning: Could not write to log file: {e}")
    
    def log_command(self, command, args=None):
        """
        Log a command execution.
        
        Args:
            command: Command name
            args: Command arguments (optional)
        """
        if args:
            self.log(f"Command: {command} {' '.join(str(arg) for arg in args)}")
        else:
            self.log(f"Command: {command}")
    
    def log_label_generation(self, date_str, message=None, border_message=None, message_only=False, count=1):
        """
        Log label generation details.
        
        Args:
            date_str: Date string used
            message: Main message (optional)
            border_message: Border message (optional) 
            message_only: Whether in message-only mode
            count: Number of labels
        """
        self.log("--- Label Generation ---")
        self.log(f"Date: {date_str}")
        if message:
            self.log(f"Message: '{message}' (length: {len(message)})")
        if border_message:
            self.log(f"Border message: '{border_message}' (length: {len(border_message)})")
        self.log(f"Message-only mode: {message_only}")
        self.log(f"Label count: {count}")
    
    def log_font_info(self, text, font_size, lines, text_type="message"):
        """
        Log font sizing information.
        
        Args:
            text: Text that was sized
            font_size: Final font size used
            lines: Lines of text after wrapping
            text_type: Type of text (message, border_message, date)
        """
        self.log(f"{text_type.title()} font: '{text}' -> {font_size}px")
        if len(lines) > 1:
            self.log(f"  Wrapped into {len(lines)} lines: {lines}")
    
    def log_printer_info(self, printer_name, label_dimensions, printer_info=None):
        """
        Log printer information.
        
        Args:
            printer_name: Name of printer
            label_dimensions: (width, height) in pixels
            printer_info: Additional printer details (optional)
        """
        self.log("--- Printer Information ---")
        self.log(f"Printer: {printer_name}")
        self.log(f"Label dimensions: {label_dimensions[0]}x{label_dimensions[1]} pixels")
        if printer_info:
            for key, value in printer_info.items():
                self.log(f"  {key}: {value}")
    
    def log_error(self, error_msg, exception=None):
        """
        Log an error.
        
        Args:
            error_msg: Error message
            exception: Exception object (optional)
        """
        self.log(f"ERROR: {error_msg}")
        if exception:
            self.log(f"  Exception: {str(exception)}")
    
    def log_success(self, operation, details=None):
        """
        Log a successful operation.
        
        Args:
            operation: Operation that succeeded
            details: Additional details (optional)
        """
        self.log(f"SUCCESS: {operation}")
        if details:
            self.log(f"  Details: {details}")
    
    def save_label_preview(self, image, filename="label_preview.png"):
        """
        Save label preview image to log directory.
        
        Args:
            image: PIL Image object
            filename: Filename for preview
        """
        if not self.current_log_dir:
            self.create_log_session()
        
        preview_path = self.current_log_dir / filename
        try:
            image.save(preview_path)
            self.log(f"Preview saved: {preview_path}")
            # Also mirror into recent using the same folder structure under logs
            try:
                # Compute the relative session subpath under the base logs directory
                rel = self.current_log_dir.relative_to(self.base_dir)
                archive_root = self.base_dir.parent / "recent"
                archive_dir = archive_root / rel
                archive_dir.mkdir(parents=True, exist_ok=True)
                archive_path = archive_dir / filename
                image.save(archive_path)
                self.log(f"Preview archived: {archive_path}")
            except Exception as e:
                self.log(f"WARNING: Could not mirror preview to recent: {e}")
            return preview_path
        except Exception as e:
            self.log_error(f"Could not save preview to {preview_path}", e)
            return None
    
    def get_log_directory(self):
        """Get the current log directory path."""
        return self.current_log_dir
    
    def get_log_file_path(self):
        """Get the current log file path."""
        return self.log_file_path
    
    def mirror_request_file(self, filename="request.json"):
        """Mirror a request.json file from logs to recent."""
        try:
            source_path = self.current_log_dir / filename
            if not source_path.is_file():
                return
                
            # Compute the relative session subpath under the base logs directory
            rel = self.current_log_dir.relative_to(self.base_dir)
            archive_root = self.base_dir.parent / "recent"
            archive_dir = archive_root / rel
            archive_dir.mkdir(parents=True, exist_ok=True)
            archive_path = archive_dir / filename
            
            # Copy the request file
            import shutil
            shutil.copy2(source_path, archive_path)
            self.log(f"Request file mirrored: {archive_path}")
        except Exception as e:
            self.log(f"WARNING: Could not mirror request file to recent: {e}")


def create_logger(base_dir="logs"):
    """
    Convenience function to create a logger instance.
    
    Args:
        base_dir: Base directory for logs
        
    Returns:
        LabelPrinterLogger instance
    """
    return LabelPrinterLogger(base_dir)


# Example usage
if __name__ == "__main__":
    # Test the logger
    logger = create_logger()
    
    logger.log("Testing the logger module")
    logger.log_command("test_command", ["arg1", "arg2"])
    logger.log_label_generation("August 09, 2025", "Test Message", count=1)
    logger.log_font_info("Test Message", 45, ["Test Message"])
    logger.log_printer_info("Test Printer", (456, 253))
    logger.log_success("Logger test completed")
    
    print(f"Log created at: {logger.get_log_file_path()}")

# --- End of content from: logger.py ---

# --- Start of content from: pi-label-printer.py ---

import time
import subprocess
import json
import os
import sys
import argparse
from datetime import datetime

from PIL import Image, ImageDraw, ImageFont

from logger import create_logger

# BLE printer module (no-op on Windows if you want)
try:
    from rw402b_ble.printer import RW402BPrinter
except Exception as e:
    # You can keep running in preview mode without this on Windows
    RW402BPrinter = None


# --- CONFIGURATION ---

import platform

def get_config_file():
    """Return the appropriate config file path based on OS."""
    system = platform.system().lower()
    if system == "windows":
        return "config/printer-config-windows.json"
    elif system == "linux":
        return "config/printer-config-linux.json"
    else:
        return "config/printer-config.json"

def load_config():
    """Load configuration from the appropriate JSON file based on OS."""
    config_file = get_config_file()
    if not os.path.exists(config_file):
        print(f"\nERROR: Configuration file '{config_file}' not found!")
        print("\nPlease create a printer-config.json file with the following structure:")
        print(json.dumps({
            "default_printer": "Your Printer Name",
            "date_format": "%B %d, %Y",
            "font_path": "C:\\Windows\\Fonts\\arial.ttf",
            "max_retries": 3,
            "wait_between_tries": 2,
            "pause_between_labels": 1,
            "month_size_ratios": {
                "January": 0.15,
                "February": 0.15
                # ... add other months as needed
            },
            "windows_device_caps": {
                "PHYSICALWIDTH": 110,
                "PHYSICALHEIGHT": 111,
                "LOGPIXELSX": 88,
                "LOGPIXELSY": 90,
                "HORZRES": 8,
                "VERTRES": 10,
                "PHYSICALOFFSETX": 112,
                "PHYSICALOFFSETY": 113
            },
            "printers": {
                "Your Printer Name": {
                    "label_width_in": 2.25,
                    "label_height_in": 1.25,
                    "dpi": 203,
                    "bottom_margin": 15,
                    "bluetooth_device_name": "",
                    "bluetooth_wait_time": 3
                }
            }
        }, indent=2))
        print("\nSee README.md for detailed configuration documentation.")
        sys.exit(1)

    # Load the config file
    try:
        with open(config_file, 'r') as f:
            config = json.load(f)
        return config
    except json.JSONDecodeError as e:
        print(f"\nERROR: Invalid JSON in {config_file}: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"\nERROR: Failed to load {config_file}: {e}")
        sys.exit(1)

def save_config(config):
    """Save configuration to the appropriate JSON file based on OS."""
    config_file = get_config_file()
    with open(config_file, 'w') as f:
        json.dump(config, f, indent=2)

def get_printer_config(config, printer_name):
    """Get printer-specific configuration, creating default if needed"""
    if printer_name not in config.get("printers", {}):
        # Create default printer config
        if "printers" not in config:
            config["printers"] = {}
        config["printers"][printer_name] = {
            "label_width_in": 2.25,
            "label_height_in": 1.25,
            "dpi": 203,
            "bottom_margin": 15,
            "horizontal_offset": 0,
            "positioning_mode": "auto",
            "bluetooth_device_name": "",
            "bluetooth_wait_time": 3
        }
    return config["printers"][printer_name]



def wrap_text_to_fit(text, font, draw, max_width):
    """
    Wrap text at word boundaries to fit within max_width.
    Returns a list of lines.
    """
    words = text.split()
    lines = []
    current_line = []
    
    for word in words:
        # Test if adding this word would exceed max width
        test_line = ' '.join(current_line + [word])
        bbox = draw.textbbox((0, 0), test_line, font=font)
        test_width = bbox[2] - bbox[0]
        
        if test_width <= max_width:
            current_line.append(word)
        else:
            # If current line has words, finish it and start new line
            if current_line:
                lines.append(' '.join(current_line))
                current_line = [word]
            else:
                # Single word is too long, add it anyway to avoid infinite loop
                lines.append(word)
    
    # Add remaining words as final line
    if current_line:
        lines.append(' '.join(current_line))
    
    return lines

def find_optimal_font_size(text, font_path, draw, max_width, max_height, min_size=10, max_size=500):
    """Find the largest font size that fits within the given constraints."""
    optimal_size = min_size
    for size in range(min_size, max_size):
        # Test with 20% larger font size
        test_size = int(size * 1.2)
        test_size = min(test_size, max_size)
        
        font = ImageFont.truetype(font_path, test_size)
        bbox = draw.textbbox((0, 0), text, font=font)
        text_width = bbox[2] - bbox[0]
        text_height = bbox[3] - bbox[1]
        
        if text_height > max_height or text_width > max_width:
            optimal_size = max(size - 1, min_size)
            break
        optimal_size = size
    
    # Return the 20% increased size of the optimal base size
    return int(optimal_size * 1.2)

def find_optimal_font_size_for_wrapped_text(text, font_path, draw, max_width, max_height, min_size=10, max_size=500):
    """Find optimal font size for text that will be wrapped to fit within constraints."""
    optimal_size = int(min_size * 1.2)  # Initialize with 20% increased min size
    final_lines = []
    final_total_height = 0
    
    # Set a reasonable upper bound based on available height (don't let font be larger than 80% of available height)
    reasonable_max = min(max_size, int(max_height * 0.8))
    
    for size in range(min_size, reasonable_max):
        # Test with 20% larger font size
        test_size = int(size * 1.2)
        test_size = min(test_size, max_size)
        
        font = ImageFont.truetype(font_path, test_size)
        wrapped_lines = wrap_text_to_fit(text, font, draw, max_width)
        
        # Calculate total height needed for all lines
        line_heights = []
        for line in wrapped_lines:
            bbox = draw.textbbox((0, 0), line, font=font)
            line_heights.append(bbox[3] - bbox[1])
        
        line_spacing = 2
        total_height = sum(line_heights) + (len(wrapped_lines) - 1) * line_spacing
        
        # Also check if text fits within width (important for single long words)
        text_width = 0
        for line in wrapped_lines:
            bbox = draw.textbbox((0, 0), line, font=font)
            line_width = bbox[2] - bbox[0]
            text_width = max(text_width, line_width)
        
        if total_height <= max_height and text_width <= max_width:
            optimal_size = test_size  # Save the actual size we tested, not the base size
            final_lines = wrapped_lines
            final_total_height = total_height
            # Size accepted
            pass
        else:
            # Size rejected - break to avoid larger sizes
            break
    
    # Return the optimal size (already includes 20% increase)
    return optimal_size, final_lines, final_total_height

def draw_text_with_bold_effect(draw, position, text, font, fill=0):
    """Draw text with a bold effect by drawing multiple times with slight offsets."""
    x, y = position
    # Draw shadow/bold effect
    for offset_x in [-1, 0, 1]:
        for offset_y in [-1, 0, 1]:
            if offset_x == 0 and offset_y == 0:
                continue
            draw.text((x + offset_x, y + offset_y), text, font=font, fill=fill)
    
    # Draw main text
    draw.text((x, y), text, font=font, fill=fill)

def center_text_horizontally(text_width, container_width, bbox_left=0):
    """Calculate x position to center text horizontally."""
    logical_x = (container_width - text_width) // 2
    return logical_x - bbox_left

def draw_border(draw, width, height, margin=4, thickness=6):
    """Draw a border around the image."""
    left = margin
    top = margin
    right = width - margin
    bottom = height - margin
    
    for i in range(thickness):
        # Top border
        draw.rectangle([left + i, top + i, right - i, top + i], fill=0)
        # Bottom border
        draw.rectangle([left + i, bottom - i, right - i, bottom - i], fill=0)
        # Left border
        draw.rectangle([left + i, top + i, left + i, bottom - i], fill=0)
        # Right border
        draw.rectangle([right - i, top + i, right - i, bottom - i], fill=0)

def draw_date_at_bottom(draw, date_str, font, width_px, height_px, bottom_margin):
    """Draw date text at the bottom of the label."""
    bbox = draw.textbbox((0, 0), date_str, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]
    
    # Position and draw the date
    date_y = height_px - bottom_margin - text_height
    draw_x = center_text_horizontally(text_width, width_px, bbox[0])
    draw_y = date_y - bbox[1]
    
    # Safety bounds checking
    draw_x = max(0, min(draw_x, width_px - text_width))
    
    draw.text((draw_x, draw_y), date_str, font=font, fill=0)
    return date_y, text_height

def draw_rotated_date_at_top(image, draw, date_str, font, width_px, top_margin=15):
    """Draw rotated (upside down) date at the top of the label."""
    bbox = draw.textbbox((0, 0), date_str, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]
    
    # Create temporary image for rotation
    temp_img = Image.new('L', (text_width + 40, text_height + 40), 255)
    temp_draw = ImageDraw.Draw(temp_img)
    temp_draw.text((20 - bbox[0], 20 - bbox[1]), date_str, font=font, fill=0)
    
    # Rotate and position
    rotated_temp = temp_img.rotate(180, expand=True)
    rotated_x = (width_px - rotated_temp.width) // 2
    rotated_y = top_margin
    
    # Create mask and paste onto main image
    mask = rotated_temp.point(lambda x: 255 if x < 128 else 0, mode='1')
    black_overlay = Image.new('L', rotated_temp.size, 0)
    image.paste(black_overlay, (rotated_x, rotated_y), mask)
    
    return rotated_y + rotated_temp.height

def draw_rotated_text(image, draw, text, font, width_px, zone_start, zone_end, rotation=0):
    """Draw text in a zone with optional 180° rotation for bottom zones."""
    bbox = draw.textbbox((0, 0), text, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]
    
    if rotation == 180:
        # Create temporary image for rotation (reusing existing rotation logic)
        temp_img = Image.new('L', (text_width + 40, text_height + 40), 255)
        temp_draw = ImageDraw.Draw(temp_img)
        temp_draw.text((20 - bbox[0], 20 - bbox[1]), text, font=font, fill=0)
        
        # Rotate 180 degrees
        rotated_temp = temp_img.rotate(180, expand=True)
        
        # Calculate position in zone
        zone_center_y = (zone_start + zone_end) // 2
        rotated_x = (width_px - rotated_temp.width) // 2
        rotated_y = zone_center_y - rotated_temp.height // 2
        
        # Create mask and paste onto main image
        mask = rotated_temp.point(lambda x: 255 if x < 128 else 0, mode='1')
        black_overlay = Image.new('L', rotated_temp.size, 0)
        image.paste(black_overlay, (rotated_x, rotated_y), mask)
        
    else:
        # Normal orientation - center in zone
        zone_center_y = (zone_start + zone_end) // 2
        draw_x = center_text_horizontally(text_width, width_px, bbox[0])
        draw_y = zone_center_y - text_height // 2 - bbox[1]
        draw.text((draw_x, draw_y), text, font=font, fill=0)

def draw_text_in_zone(image, draw, text, font_path, zone_start, zone_end, width_px, rotation=0, min_font=10, max_font=500, extra_padding=0, layout=None):
    """DRY function to draw text in any zone with proper font sizing and optional rotation."""
    # Apply additional padding if specified (for border text)
    effective_zone_start = zone_start + extra_padding
    effective_zone_end = zone_end - extra_padding
    available_height = effective_zone_end - effective_zone_start
    
    # Use printable width if layout is provided, otherwise fallback to 90% of total width
    if layout and 'printable_width' in layout:
        max_text_width = int(layout['printable_width'] * 0.95)  # 95% of printable width for safety
    else:
        max_text_width = int(width_px * 0.9)
    
    font_size, wrapped_lines, total_height = find_optimal_font_size_for_wrapped_text(
        text, font_path, draw, max_text_width, available_height, min_font, max_font
    )
    
    # Removed debug output for cleaner production use
    
    font = ImageFont.truetype(font_path, font_size)
    
    if len(wrapped_lines) == 1:
        # Single line - use rotation-aware drawing with effective zones
        draw_rotated_text(image, draw, wrapped_lines[0], font, width_px, effective_zone_start, effective_zone_end, rotation)
    else:
        # Multiple lines - use centered message approach (no rotation for wrapped text)
        if rotation == 0:
            draw_centered_message(draw, text, font_path, width_px, effective_zone_start, effective_zone_end, min_font, max_font)
        else:
            # For rotated multi-line text, fall back to single line or handle differently
            draw_rotated_text(image, draw, text, font, width_px, effective_zone_start, effective_zone_end, rotation)

def draw_centered_message(draw, message, font_path, width_px, space_start, space_end, min_font=10, max_font=500):
    """Draw a centered message with text wrapping and bold effect."""
    available_height = space_end - space_start
    max_message_width = int(width_px * 0.9)
    
    # Find optimal font size and get wrapped lines
    message_font_size, final_lines, final_total_height = find_optimal_font_size_for_wrapped_text(
        message, font_path, draw, max_message_width, available_height, min_font, max_font
    )
    
    if not final_lines:  # Fallback if no size works
        font = ImageFont.truetype(font_path, min_font)
        final_lines = wrap_text_to_fit(message, font, draw, max_message_width)
        final_total_height = len(final_lines) * min_font  # Rough estimate
        message_font_size = min_font
    
    message_font = ImageFont.truetype(font_path, message_font_size)
    
    # Calculate vertical centering
    block_start_y = space_start + (available_height - final_total_height) // 2
    
    # Draw each line centered
    current_y = block_start_y
    line_spacing = 2
    
    for line in final_lines:
        bbox = draw.textbbox((0, 0), line, font=message_font)
        text_width = bbox[2] - bbox[0]
        
        draw_x = center_text_horizontally(text_width, width_px, bbox[0])
        draw_y = current_y - bbox[1]
        
        # Draw with bold effect
        draw_text_with_bold_effect(draw, (draw_x, draw_y), line, message_font)
        
        current_y += (bbox[3] - bbox[1]) + line_spacing
    
    return message_font_size, final_lines, block_start_y

def calculate_layout_spaces(width_px, height_px, printer_config, config, date_str, date_obj, 
                           show_dates, show_main_message, show_border_message, show_side_border, draw, min_font, max_font):
    """
    Calculate layout spaces using proper zone-based layout:
    - Top Zone (25%): Border text (readable right-side-up)
    - Middle Zone (50%): Main message or dates
    - Bottom Zone (25%): Border text (readable right-side-up, mirrored)
    - 3px padding throughout
    """
    layout = {}
    
    # Calculate printable area inside the border (4px margin + 6px thickness = 10px from edges)
    border_margin = 4
    border_thickness = 6
    border_offset = border_margin + border_thickness
    
    printable_width = width_px - (2 * border_offset)
    printable_height = height_px - (2 * border_offset)
    printable_start_y = border_offset
    
    # Define the 25%/50%/25% zones within printable area with 3px padding
    padding = 3
    zone_height = printable_height / 4  # Each 25% zone of printable area
    
    # Top zone (25% of printable area) - for border text
    layout['top_zone_start'] = printable_start_y + padding
    layout['top_zone_end'] = printable_start_y + int(zone_height) - padding
    
    # Middle zone (50% of printable area) - for main content
    layout['middle_zone_start'] = printable_start_y + int(zone_height) + padding
    layout['middle_zone_end'] = printable_start_y + int(3 * zone_height) - padding
    
    # Bottom zone (25% of printable area) - for border text (mirrored)
    layout['bottom_zone_start'] = printable_start_y + int(3 * zone_height) + padding
    layout['bottom_zone_end'] = printable_start_y + printable_height - padding
    
    # Calculate side border zones if needed
    if show_side_border:
        # Side borders span from bottom of top border to top of bottom border with 6px padding
        side_border_padding = 6
        layout['left_side_start_y'] = layout['top_zone_end'] + side_border_padding  
        layout['left_side_end_y'] = layout['bottom_zone_start'] - side_border_padding
        layout['right_side_start_y'] = layout['left_side_start_y']
        layout['right_side_end_y'] = layout['left_side_end_y']
        
        # Side borders are narrow zones on left and right
        side_border_width = int(zone_height)  # Use same width as top/bottom border height
        layout['left_side_start_x'] = border_offset + padding
        layout['left_side_end_x'] = layout['left_side_start_x'] + side_border_width
        layout['right_side_start_x'] = border_offset + printable_width - side_border_width - padding  
        layout['right_side_end_x'] = border_offset + printable_width - padding
    
    # Adjust printable width if side borders are present
    effective_printable_width = printable_width
    effective_printable_start_x = border_offset
    
    if show_side_border:
        # Reduce printable width by side border width on both sides
        side_border_width = int(zone_height)  # Same width as calculated above
        effective_printable_width = printable_width - (2 * side_border_width) - (2 * padding)
        effective_printable_start_x = border_offset + side_border_width + padding
    
    # Store effective printable dimensions for width validation
    layout['printable_width'] = effective_printable_width
    layout['printable_height'] = printable_height
    layout['printable_start_x'] = effective_printable_start_x
    layout['printable_start_y'] = printable_start_y
    
    # Determine what goes in each zone based on content type
    if show_border_message and not show_main_message and not show_dates:
        # Border message only: goes in top and bottom zones
        layout['border_top_start'] = layout['top_zone_start']
        layout['border_top_end'] = layout['top_zone_end']
        layout['border_bottom_start'] = layout['bottom_zone_start']
        layout['border_bottom_end'] = layout['bottom_zone_end']
        
    elif show_main_message and not show_border_message and not show_dates:
        # Main message only: goes in middle zone
        layout['main_message_start'] = layout['middle_zone_start']
        layout['main_message_end'] = layout['middle_zone_end']
        
    elif show_dates and not show_main_message and not show_border_message:
        # Dates only: goes in middle zone
        layout['date_start'] = layout['middle_zone_start']
        layout['date_end'] = layout['middle_zone_end']
        
    elif show_main_message and show_border_message and not show_dates:
        # Both messages, no dates: main in middle, border in top/bottom
        layout['main_message_start'] = layout['middle_zone_start']
        layout['main_message_end'] = layout['middle_zone_end']
        layout['border_top_start'] = layout['top_zone_start']
        layout['border_top_end'] = layout['top_zone_end']
        layout['border_bottom_start'] = layout['bottom_zone_start']
        layout['border_bottom_end'] = layout['bottom_zone_end']
        
    elif show_dates and show_main_message and not show_border_message:
        # Dates + main message: dates in top/bottom, main in middle
        layout['main_message_start'] = layout['middle_zone_start']
        layout['main_message_end'] = layout['middle_zone_end']
        layout['date_top_start'] = layout['top_zone_start']
        layout['date_top_end'] = layout['top_zone_end']
        layout['date_bottom_start'] = layout['bottom_zone_start']
        layout['date_bottom_end'] = layout['bottom_zone_end']
        
    elif show_dates and show_border_message and not show_main_message:
        # Dates + border message: dates in middle, border in top/bottom
        layout['date_start'] = layout['middle_zone_start']
        layout['date_end'] = layout['middle_zone_end']
        layout['border_top_start'] = layout['top_zone_start']
        layout['border_top_end'] = layout['top_zone_end']
        layout['border_bottom_start'] = layout['bottom_zone_start']
        layout['border_bottom_end'] = layout['bottom_zone_end']
        
    elif show_dates and show_main_message and show_border_message:
        # All three: dates in top/bottom, main in middle, border overlaid or split
        # This is a complex case - for now, prioritize dates and main message
        layout['main_message_start'] = layout['middle_zone_start']
        layout['main_message_end'] = layout['middle_zone_end']
        layout['date_top_start'] = layout['top_zone_start']
        layout['date_top_end'] = layout['top_zone_end']
        layout['date_bottom_start'] = layout['bottom_zone_start']
        layout['date_bottom_end'] = layout['bottom_zone_end']
    
    # Calculate font information for dates if needed
    if show_dates:
        month_name = date_obj.strftime("%B")
        base_ratio = 0.8  # Use most of the zone height
        max_date_height = int((layout.get('date_top_end', layout.get('date_end', zone_height)) - 
                              layout.get('date_top_start', layout.get('date_start', 0))) * base_ratio)
        max_text_width = int(width_px * 0.9)  # 90% of width
        
        date_font_size = find_optimal_font_size(date_str, config['font_path'], draw, max_text_width, max_date_height, min_font, max_font)
        layout['date_font_size'] = date_font_size
        layout['date_font'] = ImageFont.truetype(config['font_path'], date_font_size)
    
    return layout

def draw_dates(image, draw, date_str, config, layout, skip_rotated_date):
    """Draw dates in their allocated zones with proper rotation."""
    # Draw date in middle zone
    if 'date_start' in layout:
        draw_centered_message(draw, date_str, config['font_path'], image.width, 
                            layout['date_start'], layout['date_end'], 10, 500)
    
    # Draw dates in top and bottom zones with rotation
    if 'date_top_start' in layout and 'date_bottom_start' in layout:
        # Top zone - normal orientation
        draw_text_in_zone(image, draw, date_str, config['font_path'],
                         layout['date_top_start'], layout['date_top_end'],
                         image.width, rotation=0, min_font=10, max_font=500)
        
        # Bottom zone - 180° rotation for readability from opposite side  
        draw_text_in_zone(image, draw, date_str, config['font_path'],
                         layout['date_bottom_start'], layout['date_bottom_end'],
                         image.width, rotation=180, min_font=10, max_font=500)

def draw_main_message(image, draw, message, config, layout, width_px):
    """Draw main message in the middle zone with proper size validation."""
    if 'main_message_start' in layout:
        space_start = layout['main_message_start']
        space_end = layout['main_message_end']
        
        # Use the new zone-based function with layout info for width validation
        draw_text_in_zone(image, draw, message, config['font_path'],
                         space_start, space_end, width_px, 
                         rotation=0, min_font=10, max_font=500, extra_padding=0, layout=layout)

def load_and_process_image(image_path, printable_width, printable_height, logger):
    """Load PNG image and crop to fit printable area if necessary."""
    try:
        # Load the image
        user_image = Image.open(image_path)
        
        # Convert to grayscale to match label format
        if user_image.mode != 'L':
            user_image = user_image.convert('L')
            logger.log(f"Converted image from {Image.open(image_path).mode} to grayscale")
        
        original_width, original_height = user_image.size
        logger.log(f"Loaded image: {original_width}x{original_height}px from {image_path}")
        
        # Check if image needs cropping
        if original_width > printable_width or original_height > printable_height:
            # Crop from top-left corner to fit printable area
            cropped_image = user_image.crop((0, 0, min(original_width, printable_width), 
                                           min(original_height, printable_height)))
            
            # Log warning about cropping
            logger.log(f"WARNING: Image {original_width}x{original_height}px is larger than printable area {printable_width}x{printable_height}px")
            logger.log(f"Image cropped to {cropped_image.size[0]}x{cropped_image.size[1]}px from top-left corner")
            print(f"WARNING: Image cropped from {original_width}x{original_height}px to {cropped_image.size[0]}x{cropped_image.size[1]}px")
            
            return cropped_image
        else:
            logger.log(f"Image fits within printable area - no cropping needed")
            return user_image
            
    except FileNotFoundError:
        logger.log(f"ERROR: Image file not found: {image_path}")
        print(f"ERROR: Image file not found: {image_path}")
        return None
    except Exception as e:
        logger.log(f"ERROR: Failed to load image {image_path}: {str(e)}")
        print(f"ERROR: Failed to load image: {str(e)}")
        return None

def paste_image_on_label(base_image, user_image, layout):
    """Paste user image onto label in the appropriate location."""
    if user_image is None:
        return
    
    # Calculate position to center the image in the printable area
    printable_start_x = layout.get('printable_start_x', 10)
    printable_start_y = layout.get('printable_start_y', 10)
    printable_width = layout.get('printable_width', base_image.width - 20)
    printable_height = layout.get('printable_height', base_image.height - 20)
    
    image_width, image_height = user_image.size
    
    # Center the image in the printable area
    paste_x = printable_start_x + (printable_width - image_width) // 2
    paste_y = printable_start_y + (printable_height - image_height) // 2
    
    # Paste the image onto the base label
    base_image.paste(user_image, (paste_x, paste_y))

def draw_side_border_message(image, draw, side_border, config, layout, width_px, height_px):
    """Draw side border message on left and right with 90°/-90° rotation."""
    if 'left_side_start_x' not in layout:
        return
    
    # Calculate font size for side text (use same height as top/bottom borders)
    available_height = layout['left_side_end_y'] - layout['left_side_start_y']
    available_width = layout['left_side_end_x'] - layout['left_side_start_x']
    
    # Find optimal font size for the text in the side area
    # Since text will be rotated, we swap width/height for font calculation
    font_size, wrapped_lines, total_height = find_optimal_font_size_for_wrapped_text(
        side_border, config['font_path'], draw, available_height, available_width - 8, 10, 500
    )
    
    font = ImageFont.truetype(config['font_path'], font_size)
    
    # Draw left side (90° clockwise rotation)
    # For side borders, join wrapped lines with spaces to keep text on one "line"
    text = ' '.join(wrapped_lines)
    
    # Create temporary image for left side text (90° rotation)
    bbox = draw.textbbox((0, 0), text, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]
    
    temp_img = Image.new('L', (text_width + 20, text_height + 20), 255)
    temp_draw = ImageDraw.Draw(temp_img)
    temp_draw.text((10 - bbox[0], 10 - bbox[1]), text, font=font, fill=0)
    
    # Rotate 90° clockwise for left side
    rotated_left = temp_img.rotate(-90, expand=True)
    
    # Position on left side
    left_center_x = (layout['left_side_start_x'] + layout['left_side_end_x']) // 2
    left_center_y = (layout['left_side_start_y'] + layout['left_side_end_y']) // 2
    paste_x = left_center_x - rotated_left.width // 2
    paste_y = left_center_y - rotated_left.height // 2
    
    # Paste left side text
    mask = rotated_left.point(lambda x: 255 if x < 128 else 0, mode='1')
    black_overlay = Image.new('L', rotated_left.size, 0)
    image.paste(black_overlay, (paste_x, paste_y), mask)
    
    # Draw right side (90° counter-clockwise rotation)
    rotated_right = temp_img.rotate(90, expand=True)
    
    # Position on right side  
    right_center_x = (layout['right_side_start_x'] + layout['right_side_end_x']) // 2
    right_center_y = (layout['right_side_start_y'] + layout['right_side_end_y']) // 2
    paste_x = right_center_x - rotated_right.width // 2
    paste_y = right_center_y - rotated_right.height // 2
    
    # Paste right side text
    mask = rotated_right.point(lambda x: 255 if x < 128 else 0, mode='1')
    black_overlay = Image.new('L', rotated_right.size, 0)
    image.paste(black_overlay, (paste_x, paste_y), mask)

def draw_border_message(image, draw, border_message, config, layout, width_px):
    """Draw border message in top and bottom zones with proper 180° rotation for bottom."""
    # Calculate optimal padding for border text (~4px for good balance)
    # Maintains visual spacing while maximizing readable font size
    border_padding = 4
    
    # Draw in top zone (normal orientation) with extra padding
    if 'border_top_start' in layout:
        draw_text_in_zone(image, draw, border_message, config['font_path'], 
                         layout['border_top_start'], layout['border_top_end'], 
                         width_px, rotation=0, min_font=10, max_font=500, extra_padding=border_padding, layout=layout)
    
    # Draw in bottom zone (180° rotation for readability from opposite side) with extra padding
    if 'border_bottom_start' in layout:
        draw_text_in_zone(image, draw, border_message, config['font_path'],
                         layout['border_bottom_start'], layout['border_bottom_end'],
                         width_px, rotation=180, min_font=10, max_font=500, extra_padding=border_padding, layout=layout)

def reconnect_bluetooth_device(device_name):
    """
    On Raspberry Pi, BLE connection is handled automatically by the BLE routines in rw402b_ble/printer.py.
    No manual reconnect is needed; a new connection will be attempted each print.
    """
    
def generate_label_image(date_str, date_obj, config, printer_config, message=None, border_message=None, side_border=None, show_date=False, image_path=None, logger=None):
    """Generate a label image with dates and/or message."""
    # Create image based on printer-specific settings
    width_px = int(printer_config['label_width_in'] * printer_config['dpi'])
    height_px = int(printer_config['label_height_in'] * printer_config['dpi'])
    image = Image.new('L', (width_px, height_px), 255)
    draw = ImageDraw.Draw(image)

    # Get font configuration
    min_font = config.get('min_font_size', 10)
    max_font = config.get('max_font_size', 500)
    
    # Determine what content to show
    show_dates = show_date  # Now dates are only shown when -o flag is present
    show_main_message = message is not None
    show_border_message = border_message is not None
    show_side_border = side_border is not None
    
    # Calculate layout spaces based on what content we're showing
    layout = calculate_layout_spaces(width_px, height_px, printer_config, config, date_str, date_obj, 
                                    show_dates, show_main_message, show_border_message, show_side_border, draw, min_font, max_font)
    
    # Layout calculation complete
    
    # Load and process user image if provided
    user_image = None
    if image_path:
        printable_width = layout.get('printable_width', width_px - 20)
        printable_height = layout.get('printable_height', height_px - 20)
        user_image = load_and_process_image(image_path, printable_width, printable_height, logger)
        
        # Paste the image onto the label (behind text content)
        if user_image:
            paste_image_on_label(image, user_image, layout)
    
    # Draw each type of content in its allocated space (over the image)
    if show_dates:
        draw_dates(image, draw, date_str, config, layout, show_border_message)
    
    if show_main_message:
        draw_main_message(image, draw, message, config, layout, width_px)
    
    if show_border_message:
        draw_border_message(image, draw, border_message, config, layout, width_px)
    
    if show_side_border:
        draw_side_border_message(image, draw, side_border, config, layout, width_px, height_px)
    
    # Draw border
    draw_border(draw, width_px, height_px)
    
    # Debug output
    print(f"\n=== Debug Info ===")
    print(f"Show dates: {show_dates}")
    if show_dates:
        print(f"Date string: '{date_str}', font size: {layout.get('date_font_size', 'N/A')}")
    if show_main_message:
        print(f"Message: '{message}' (length: {len(message)})")
    if show_border_message:
        print(f"Border message: '{border_message}' (length: {len(border_message)})")
    if show_side_border:
        print(f"Side border message: '{side_border}' (length: {len(side_border)})")
    print(f"Label dimensions: {width_px}x{height_px}")
    
    image.save("label_preview.png")  # Optional preview
    return image

def print_label(image, printer_name, config, printer_config):
    """
    On Linux/Pi: send the PIL image to RW402B over BLE using TSPL.
    """

    # ---- Linux/Pi BLE path ----
    if RW402BPrinter is None:
        print("BLE printer module not available. Install it or run in --preview-only.")
        return False

    try:
        dpi = int(printer_config.get('dpi', 203))
        label_w_in = float(printer_config.get('label_width_in', 2.25))
        label_h_in = float(printer_config.get('label_height_in', 1.25))

        # Convert inches -> mm for TSPL SIZE command
        label_w_mm = label_w_in * 25.4
        label_h_mm = label_h_in * 25.4

        gap_mm     = float(printer_config.get('gap_mm', 3.0))
        density    = int(printer_config.get('density', 8))
        speed      = int(printer_config.get('speed', 4))
        direction  = int(printer_config.get('direction', 1))
        invert     = bool(printer_config.get('invert', True))  # you found invert=True works

        # Optional: fixed BLE MAC; if absent we auto-scan by name (RW402B/Munbyn/Beeprt)
        ble_mac = printer_config.get('ble_mac') or None

        # Fire!
        p = RW402BPrinter(addr=ble_mac, timeout=float(printer_config.get('bluetooth_wait_time', 4.0)),
                          dpi=dpi, invert=invert)
        p.print_pil_image(
            image,
            label_w_mm=label_w_mm,
            label_h_mm=label_h_mm,
            gap_mm=gap_mm,
            density=density,
            speed=speed,
            direction=direction,
            x=0, y=0, mode=0
        )
        print("Label sent over BLE to RW402B.")
        return True

    except Exception as e:
        print(f"BLE printing failed: {e}")
        import traceback
        traceback.print_exc()
        return False



def _print_profiling_summary(profile):
    """Print a concise profiling summary of major steps."""
    def ms(sec):
        return int(sec * 1000)

    print("\n=== Profiling Summary ===")
    if 'config_load' in profile:
        print(f"Config load: {ms(profile.get('config_load', 0))} ms")
    if 'bluetooth_wait' in profile and profile.get('bluetooth_wait', 0) > 0:
        print(f"Bluetooth wait: {ms(profile.get('bluetooth_wait', 0))} ms")
    if 'image_generation' in profile:
        print(f"Image generation: {ms(profile.get('image_generation', 0))} ms")
    if 'preview_save' in profile:
        print(f"Preview save: {ms(profile.get('preview_save', 0))} ms")

    # Printing details
    prints = profile.get('print_success_times', [])
    attempts = profile.get('print_attempt_times', [])
    if attempts:
        total_attempt_time = sum(attempts)
        print(f"Print attempts: {len(attempts)} attempts, {ms(total_attempt_time)} ms total")
    if prints:
        total_print_time = sum(prints)
        avg = total_print_time / len(prints)
        print(f"Successful prints: {len(prints)}, total {ms(total_print_time)} ms, avg {ms(avg)} ms")
    elif attempts:
        print("Successful prints: 0")

    # Total wall time
    if 'start' in profile and 'end' in profile:
        total = profile['end'] - profile['start']
        print(f"Total runtime: {ms(total)} ms")


if __name__ == "__main__":
    _profile = {
        'start': time.perf_counter(),
        'print_success_times': [],
        'print_attempt_times': [],
    }
    # Initialize logger
    logger = create_logger()
    
    # Set up argument parser
    parser = argparse.ArgumentParser(
        description='Print date labels on a thermal label printer',
        epilog='Configuration is stored in printer-config.json (must be created manually)'
    )
    parser.add_argument('-c', '--count', type=int, default=1, 
                        help='Number of labels to print (default: 1)')
    parser.add_argument('-d', '--date', type=str, 
                        help='Specific date to print (format: YYYY-MM-DD, default: today)')
    parser.add_argument('-m', '--message', type=str, 
                        help='Custom message to print in center of label')
    parser.add_argument('-b', '--border-message', type=str,
                        help='Custom border message - appears on top and bottom borders with rotation')
    parser.add_argument('-s', '--side-border', type=str,
                        help='Custom side border message - appears on left and right sides with 90°/-90° rotation')
    parser.add_argument('-i', '--image', type=str,
                        help='Path to PNG image file to include on label (will be cropped to fit printable area if oversized)')
    parser.add_argument('-o', '--show-date', action='store_true',
                        help='Show dates on the label (dates are hidden by default)')
    parser.add_argument('-p', '--preview-only', action='store_true',
                        help='Generate label image only (do not print to printer)')
    args = parser.parse_args()
    
    # Log the command execution
    logger.log_command("label-printer.py", sys.argv[1:])
    
    # Load configuration
    _t0 = time.perf_counter()
    config = load_config()
    _profile['config_load'] = time.perf_counter() - _t0
    logger.log("Configuration loaded successfully")
    
    # Step 1: Get printer selection
    selected_printer = "RW402B"
    
    # Get printer-specific configuration
    printer_config = get_printer_config(config, selected_printer)
    
    # Step 2: Try to connect to Bluetooth printer (best effort)
    if printer_config['bluetooth_device_name']:
        _t0 = time.perf_counter()
        reconnect_bluetooth_device(printer_config['bluetooth_device_name'])
        print("Waiting for Bluetooth device to connect...")
        time.sleep(printer_config['bluetooth_wait_time'])
        _profile['bluetooth_wait'] = time.perf_counter() - _t0

    # Step 3: Generate the label image
    if args.date:
        try:
            # Parse the provided date
            date_obj = datetime.strptime(args.date, "%Y-%m-%d")
            date_str = date_obj.strftime(config['date_format'])
            print(f"Using specified date: {date_str}")
        except ValueError:
            print(f"Invalid date format: {args.date}. Please use YYYY-MM-DD format.")
            exit(1)
    else:
        date_obj = datetime.now()
        date_str = date_obj.strftime(config['date_format'])
    
    # Log label generation details
    logger.log_label_generation(date_str, args.message, args.border_message, not args.show_date, args.count)
    
    _t0 = time.perf_counter()
    label_img = generate_label_image(date_str, date_obj, config, printer_config, args.message, args.border_message, args.side_border, args.show_date, args.image, logger)
    _profile['image_generation'] = time.perf_counter() - _t0
    print(f"Label image generated for: {date_str}")
    logger.log_success("Label image generated", f"Date: {date_str}, Dimensions: {label_img.size}")
    
    # Save preview to log directory
    _t0 = time.perf_counter()
    logger.save_label_preview(label_img)
    _profile['preview_save'] = time.perf_counter() - _t0

    # Step 4: Print the requested number of labels (or just generate preview)
    if args.preview_only:
        print(f"Preview mode: Label image generated only (not printed)")
        logger.log("Preview mode: No printing requested")
    else:
        print(f"\nPrinting {args.count} label(s)...")
        logger.log(f"Starting print job: {args.count} label(s) to {selected_printer}")
    
        for label_num in range(1, args.count + 1):
            if args.count > 1:
                print(f"\nLabel {label_num} of {args.count}:")
                logger.log(f"Printing label {label_num} of {args.count}")
            
            # Try printing with retries
            for attempt in range(config['max_retries']):
                print(f"  Print attempt {attempt + 1} of {config['max_retries']}...")
                logger.log(f"Print attempt {attempt + 1} of {config['max_retries']}")
                _t0 = time.perf_counter()
                success = print_label(label_img, selected_printer, config, printer_config)
                _elapsed = time.perf_counter() - _t0
                _profile['print_attempt_times'].append(_elapsed)
                if success:
                    _profile['print_success_times'].append(_elapsed)
                    logger.log_success(f"Label {label_num} printed successfully")
                    if label_num < args.count:
                        time.sleep(config.get('pause_between_labels', 1))
                    break
                else:
                    logger.log_error(f"Print attempt {attempt + 1} failed")
                    print(f"  Retrying in {config['wait_between_tries']} seconds...")
                    time.sleep(config['wait_between_tries'])
            else:
                error_msg = "Failed to print after multiple attempts. Is the printer powered on, paired, and connected?"
                print(error_msg)
                logger.log_error(error_msg)
                _profile['end'] = time.perf_counter()
                _print_profiling_summary(_profile)
                exit(1)
    
        print(f"\nSuccessfully printed {args.count} label(s).")
        logger.log_success("Print job completed", f"{args.count} label(s) printed successfully")

    # Always print profiling summary at the end
    _profile['end'] = time.perf_counter()
    _print_profiling_summary(_profile)


# --- End of content from: pi-label-printer.py ---

# --- Start of content from: server.py ---

from flask import Flask, jsonify, request, Response, send_from_directory, send_file
import subprocess
import sys
import os
import html
import re
import time
from pathlib import Path
from datetime import datetime
from urllib.parse import quote, unquote
from PIL import Image

# Try to import BLE printer for direct reprint support
try:
    from rw402b_ble.printer import RW402BPrinter
except Exception:  # noqa: E722
    RW402BPrinter = None


app = Flask(__name__)


@app.route('/', methods=['GET'])
@app.route('/index.html', methods=['GET'])
def root_index():
    """Serve the main UI at the root path for convenience."""
    return send_from_directory(os.path.join(os.path.dirname(__file__), "www"), "index.html")


@app.route("/api/pi-label/options", methods=["GET"])
def get_pi_label_options():
    """
    Return the available CLI options for pi-label-printer.py as JSON.
    This mirrors the argparse flags defined in pi-label-printer.py.
    """
    options = [
        {
            "flag": "-c",
            "long_flag": "--count",
            "type": "int",
            "default": 1,
            "description": "Number of labels to print",
        },
        {
            "flag": "-d",
            "long_flag": "--date",
            "type": "string",
            "format": "YYYY-MM-DD",
            "description": "Specific date to print (default: today)",
        },
        {
            "flag": "-m",
            "long_flag": "--message",
            "type": "string",
            "description": "Custom message to print in center of label",
        },
        {
            "flag": "-b",
            "long_flag": "--border-message",
            "type": "string",
            "description": "Custom border message for top and bottom borders",
        },
        {
            "flag": "-s",
            "long_flag": "--side-border",
            "type": "string",
            "description": "Custom side border message (left/right, rotated)",
        },
        {
            "flag": "-i",
            "long_flag": "--image",
            "type": "string",
            "description": "Path to PNG image to include (cropped to fit)",
        },
        {
            "flag": "-o",
            "long_flag": "--show-date",
            "type": "bool",
            "default": False,
            "description": "Show dates on the label (hidden by default)",
        },
        {
            "flag": "-p",
            "long_flag": "--preview-only",
            "type": "bool",
            "default": False,
            "description": "Generate label image only (do not print)",
        },
    ]

    return jsonify({
        "script": "pi-label-printer.py",
        "endpoint": "/app/pi-label/options",
        "options": options,
    })


@app.route("/app/pi-label", methods=["GET"])
def pi_label_form():
    """Serve the HTML UI (now also available at /app via index.html)."""
    return send_from_directory(os.path.join(os.path.dirname(__file__), "www"), "index.html")


# --- Helpers ---

def _find_latest_preview():
    """Search for the newest label_preview.png under logs/ and project root."""
    base_dir = Path(os.path.dirname(__file__))
    candidates = []
    root_preview = base_dir / "label_preview.png"
    if root_preview.is_file():
        candidates.append(root_preview)

    logs_dir = base_dir / "logs"
    if logs_dir.is_dir():
        try:
            for p in logs_dir.rglob("label_preview.png"):
                if p.is_file():
                    candidates.append(p)
        except Exception:
            pass

    if not candidates:
        return None
    return max(candidates, key=lambda p: p.stat().st_mtime)


def _find_latest_metrics():
    """If a metrics.json exists next to the latest preview, load and return it."""
    p = _find_latest_preview()
    if not p:
        return None
    metrics_path = p.with_name('metrics.json')
    if metrics_path.is_file():
        try:
            import json
            with open(metrics_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception:
            return None
    return None


def _save_request_data(preview_path: Path, request_data: dict):
    """Save the original request data next to the generated preview for template reprinting."""
    try:
        import json
        request_path = preview_path.with_name('request.json')
        # Create a normalized request for deduplication
        normalized_request = _normalize_request_for_template_matching(request_data)
        
        with open(request_path, 'w', encoding='utf-8') as f:
            json.dump({
                'original_request': request_data,
                'normalized_template': normalized_request,
                'timestamp': datetime.now().isoformat()
            }, f, indent=2)
    except Exception:
        pass  # Don't fail the main operation if we can't save request data


def _mirror_request_data_to_past_images(logs_preview_path: Path):
    """Mirror request.json from logs to recent after label generation."""
    try:
        # Check if we have a logger-generated request file to mirror
        import sys
        sys.path.append(str(Path(__file__).parent))
        from logger import create_logger
        
        # Create a temporary logger to use its mirror functionality
        logs_root = _logs_dir()
        if str(logs_preview_path).startswith(str(logs_root)):
            log_dir = logs_preview_path.parent
            # Create logger with the specific session directory
            temp_logger = create_logger(str(logs_root))
            temp_logger.current_log_dir = log_dir
            temp_logger.mirror_request_file()
    except Exception as e:
        pass


def _load_request_data(preview_path: Path):
    """Load the original request data for a preview if available."""
    try:
        import json
        request_path = preview_path.with_name('request.json')
        if request_path.is_file():
            with open(request_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                return data.get('original_request'), data.get('normalized_template')
    except Exception:
        pass
    return None, None


def _normalize_request_for_template_matching(request_data: dict) -> dict:
    """Create a normalized request for template matching."""
    # Remove fields that don't affect the template
    exclude_keys = {'preview_only', 'list', 'count'}
    normalized = {}
    
    for k, v in request_data.items():
        if k in exclude_keys:
            continue
        # Only include non-empty values
        if v is not None and v != '' and v != False:
            normalized[k] = v
    
    return normalized


def _find_existing_template_match(new_request_data: dict) -> Path | None:
    """Find existing label with the same template (request pattern), if any."""
    try:
        import json
        from datetime import datetime
        
        # Normalize the new request
        normalized_new = _normalize_request_for_template_matching(new_request_data)
        
        # Only search recent directory (logs is write-once only)
        past_images = _past_images_dir()
        if not past_images.is_dir():
            return None
        
        found_files = []
        best_match = None
        best_timestamp = 0
        
        for p in past_images.rglob("request.json"):
            if "deleted" in p.parts:
                continue
            found_files.append(str(p))
            try:
                with open(p, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    existing_template = data.get('normalized_template', {})
                    original_request = data.get('original_request', {})
                    
                    if existing_template == normalized_new:
                        # Check if this template has a fixed date that doesn't match today
                        existing_date = original_request.get('date')
                        new_date = new_request_data.get('date')
                        
                        # If either has a specific date and they don't match, skip this template
                        if existing_date and new_date and existing_date != new_date:
                            continue
                        elif existing_date and not new_date:
                            # Existing has fixed date, new wants current date - check if it matches today
                            today = datetime.now().strftime('%Y-%m-%d')
                            if existing_date != today:
                                continue
                        elif not existing_date and new_date:
                            # Existing uses current date, new wants fixed date - don't reuse
                            continue
                        
                        # Found a compatible match, check if preview exists
                        preview_path = p.with_name('label_preview.png')
                        if preview_path.is_file():
                            # Get the timestamp and keep the most recent match
                            timestamp = preview_path.stat().st_mtime
                            if timestamp > best_timestamp:
                                best_match = preview_path
                                best_timestamp = timestamp
            except Exception as e:
                continue
        
        if best_match:
            print(f"Template reused: {best_match.parent.name}")
            return best_match
    except Exception as e:
        pass
    return None


def _parse_metrics_from_stdout(stdout: str):
    """Look for a line like 'METRICS: {json}' and parse it."""
    try:
        for line in stdout.splitlines():
            if line.startswith('METRICS:'):
                import json
                payload = line.partition('METRICS:')[2].strip()
                return json.loads(payload)
    except Exception:
        pass
    return None


def _logs_dir() -> Path:
    return Path(os.path.dirname(__file__)) / "logs"


def _past_images_dir() -> Path:
    return Path(os.path.dirname(__file__)) / "recent"


def _list_recent_previews(limit: int = 100):
    # Prefer recent as the canonical recent source; fallback to logs
    base = _past_images_dir()
    if not base.is_dir():
        base = _logs_dir()
    items = []
    if not base.is_dir():
        return []
    try:
        for p in base.rglob("label_preview.png"):
            try:
                stat = p.stat()
            except Exception:
                continue
            # Skip files in deleted subdirectory
            if "deleted" in p.parts:
                continue
            rel = p.relative_to(Path(os.path.dirname(__file__)))
            items.append({
                'path': str(rel).replace('\\', '/'),
                'mtime_ts': int(stat.st_mtime),
                'mtime_iso': datetime.fromtimestamp(stat.st_mtime).isoformat(timespec='seconds'),
                'size': stat.st_size,
            })
        items.sort(key=lambda x: x['mtime_ts'], reverse=True)
        return items[:limit]
    except Exception:
        return []


def _safe_path_from_query(rel_path: str) -> Path | None:
    """Ensure requested path is inside the workspace and under recent/.* or logs/.*"""
    try:
        base = Path(os.path.dirname(__file__))
        target = (base / rel_path).resolve()
        logs = (_logs_dir()).resolve()
        past = (_past_images_dir()).resolve()
        if not (str(target).startswith(str(logs)) or str(target).startswith(str(past))):
            return None
        if not target.is_file():
            return None
        return target
    except Exception:
        return None


def _get_config_file_for_os() -> Path:
    system = sys.platform.lower()
    base = Path(os.path.dirname(__file__))
    if system.startswith('win'):
        return base / 'config' / 'printer-config-windows.json'
    elif system.startswith('linux'):
        return base / 'config' / 'printer-config-linux.json'
    else:
        return base / 'config' / 'printer-config.json'


def _load_printer_config():
    import json as _json
    cfg_path = _get_config_file_for_os()
    if not cfg_path.is_file():
        return None, None
    try:
        with open(cfg_path, 'r', encoding='utf-8') as f:
            cfg = _json.load(f)
        printer_name = 'RW402B'
        printers = cfg.get('printers') or {}
        pcfg = printers.get(printer_name) or {
            'label_width_in': 2.25,
            'label_height_in': 1.25,
            'dpi': 203,
            'gap_mm': 3.0,
            'density': 8,
            'speed': 4,
            'direction': 1,
            'invert': True,
            'bluetooth_wait_time': 4.0,
        }
        return cfg, pcfg
    except Exception:
        return None, None


@app.route('/api/recent', methods=['GET'])
def api_recent():
    """Return recent previews with metadata."""
    try:
        limit = int(request.args.get('limit', '100'))
    except Exception:
        limit = 100
    items = _list_recent_previews(limit)
    # attach image URLs
    for it in items:
        q = quote(it['path'])
        it['image_url'] = f"/preview/file?path={q}&ts={it['mtime_ts']}"
    return jsonify({'items': items})


@app.route('/preview/file', methods=['GET'])
def preview_by_path():
    """Serve a specific preview by relative path (under logs directory)."""
    rel = request.args.get('path')
    if not rel:
        return Response('Missing path', mimetype='text/plain'), 400
    rel = unquote(rel)
    p = _safe_path_from_query(rel)
    if not p:
        return Response('Invalid path', mimetype='text/plain'), 400
    resp = send_file(str(p), mimetype='image/png')
    resp.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    resp.headers['Pragma'] = 'no-cache'
    resp.headers['Expires'] = '0'
    return resp


@app.route('/api/reprint', methods=['POST'])
def api_reprint():
    """Reprint a saved label by regenerating it from the original request data with current dynamic values."""
    data = request.get_json(silent=True) or {}
    rel = data.get('path')
    if not rel:
        return jsonify({'error': 'Missing path'}), 400
    p = _safe_path_from_query(rel)
    if not p:
        return jsonify({'error': 'Invalid path'}), 400

    # Try to load the original request data for template reprinting
    original_request, _ = _load_request_data(p)
    if original_request:
        # Regenerate the label using the original template with current dynamic values
        try:
            # Update dynamic fields like date to current values
            updated_request = original_request.copy()
            # If the original request had date template markers but not a specific date, use today
            if 'message' in updated_request and updated_request['message'] and '{{date}}' in str(updated_request['message']):
                # Template has date placeholder - will be filled by the label generator
                pass  # Keep the template as-is
            elif 'date' not in updated_request or not updated_request['date']:
                # No specific date was provided, don't set one to use today
                updated_request.pop('date', None)
            
            # Set preview_only to False to ensure actual printing
            updated_request['preview_only'] = False
            
            # Validate the updated request
            ok, errors = validate_payload(updated_request)
            if not ok:
                return jsonify({'error': f'Invalid original request data: {errors}'}), 400
            
            cmd = build_command_from_payload(updated_request)
            
            t0 = time.perf_counter()
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=False,
            )
            elapsed_sec = time.perf_counter() - t0
            
            if result.returncode == 0:
                return jsonify({
                    'ok': True, 
                    'elapsed_sec': round(elapsed_sec, 3),
                    'method': 'template_regeneration',
                    'stdout': result.stdout.strip() if result.stdout else ''
                })
            else:
                # Fall back to direct image printing if regeneration failed
                return jsonify({
                    'error': f'Template regeneration failed: {result.stderr}',
                    'fallback_reason': 'Falling back to direct image printing'
                }), 400
                
        except Exception as e:
            # Fall back to direct image printing if template processing failed
            pass
    
    # Fallback: Direct image printing (original behavior)
    if RW402BPrinter is None:
        return jsonify({'error': 'BLE printer module not available on this host and no template data found'}), 500

    cfg, pcfg = _load_printer_config()
    if pcfg is None:
        return jsonify({'error': 'Printer config not found'}), 500

    try:
        img = Image.open(p)
    except Exception as e:
        return jsonify({'error': f'Failed to open image: {e}'}), 500

    # Pull printer settings
    try:
        dpi = int(pcfg.get('dpi', 203))
        w_in = float(pcfg.get('label_width_in', 2.25))
        h_in = float(pcfg.get('label_height_in', 1.25))
        gap_mm = float(pcfg.get('gap_mm', 3.0))
        density = int(pcfg.get('density', 8))
        speed = int(pcfg.get('speed', 4))
        direction = int(pcfg.get('direction', 1))
        invert = bool(pcfg.get('invert', True))
        ble_mac = pcfg.get('ble_mac') or None
    except Exception as e:
        return jsonify({'error': f'Invalid printer config: {e}'}), 500

    try:
        t0 = time.perf_counter()
        pble = RW402BPrinter(addr=ble_mac, timeout=float(pcfg.get('bluetooth_wait_time', 4.0)),
                              dpi=dpi, invert=invert)
        pble.print_pil_image(
            img,
            label_w_mm=w_in * 25.4,
            label_h_mm=h_in * 25.4,
            gap_mm=gap_mm,
            density=density,
            speed=speed,
            direction=direction,
            x=0, y=0, mode=0
        )
        elapsed_sec = time.perf_counter() - t0
        return jsonify({
            'ok': True, 
            'elapsed_sec': round(elapsed_sec, 3),
            'method': 'direct_image_printing'
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/delete', methods=['POST'])
def api_delete():
    """Move a past image to recent/deleted/{same folder structure}."""
    data = request.get_json(silent=True) or {}
    rel = data.get('path')
    if not rel:
        return jsonify({'error': 'Missing path'}), 400
    p = _safe_path_from_query(rel)
    if not p:
        return jsonify({'error': 'Invalid path'}), 400

    base = Path(os.path.dirname(__file__))
    try:
        # Compute path relative to recent root; if coming from logs, map logs/.. to recent/..
        past_root = _past_images_dir()
        logs_root = _logs_dir()
        if str(p).startswith(str(past_root.resolve())):
            rel_to_root = p.resolve().relative_to(past_root.resolve())
        elif str(p).startswith(str(logs_root.resolve())):
            rel_to_root = p.resolve().relative_to(logs_root.resolve())
        else:
            return jsonify({'error': 'Path not under expected roots'}), 400

        deleted_root = past_root / 'deleted'
        dest_dir = deleted_root / rel_to_root.parent
        dest_dir.mkdir(parents=True, exist_ok=True)
        dest_path = dest_dir / p.name

        # Move the file
        p.rename(dest_path)
        
        # Also move the associated request.json file if it exists
        request_file = p.with_name('request.json')
        if request_file.is_file():
            try:
                request_dest = dest_path.with_name('request.json')
                request_file.rename(request_dest)
            except Exception:
                pass  # Don't fail if we can't move the request file
        
        # Also move metrics.json if it exists
        metrics_file = p.with_name('metrics.json')
        if metrics_file.is_file():
            try:
                metrics_dest = dest_path.with_name('metrics.json')
                metrics_file.rename(metrics_dest)
            except Exception:
                pass  # Don't fail if we can't move the metrics file
        
        return jsonify({'ok': True, 'deleted_to': str(dest_path.relative_to(base)).replace('\\','/')})
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/preview.png', methods=['GET'])
def latest_preview_png():
    """Serve the most recent label preview PNG."""
    p = _find_latest_preview()
    if not p:
        return Response("Preview not found", mimetype='text/plain'), 404
    # Add a cache-busting header-friendly timestamp
    resp = send_file(str(p), mimetype='image/png')
    resp.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    resp.headers['Pragma'] = 'no-cache'
    resp.headers['Expires'] = '0'
    return resp


def build_command_from_payload(payload: dict):
    """Build command list for pi-label-printer.py based on provided payload."""
    script_path = os.path.join(os.path.dirname(__file__), 'pi-label-printer.py')
    cmd = [sys.executable or 'python3', script_path]

    # Booleans
    if payload.get('list') is True:
        cmd.append('-l')
    if payload.get('show_date') is True:
        cmd.append('-o')
    if payload.get('preview_only') is True:
        cmd.append('-p')

    # Integers
    count = payload.get('count')
    if count is not None:
        try:
            count_val = int(count)
            if count_val > 0:
                cmd.extend(['-c', str(count_val)])
        except (TypeError, ValueError):
            pass

    # Strings
    mapping = [
        ('date', '-d'),
        ('message', '-m'),
        ('border_message', '-b'),
        ('side_border', '-s'),
        ('image', '-i'),
    ]
    for key, flag in mapping:
        val = payload.get(key)
        if isinstance(val, str) and val.strip():
            cmd.extend([flag, val.strip()])

    return cmd


def validate_payload(payload: dict):
    """Validate incoming POST data. Returns (ok: bool, errors: list[str])."""
    errors = []

    # count: positive integer if provided
    if 'count' in payload and payload['count'] is not None:
        try:
            count_val = int(payload['count'])
            if count_val <= 0:
                errors.append("'count' must be a positive integer")
        except (TypeError, ValueError):
            errors.append("'count' must be an integer")

    # date: YYYY-MM-DD if provided
    date_val = payload.get('date')
    if date_val:
        if not isinstance(date_val, str) or not re.fullmatch(r"\d{4}-\d{2}-\d{2}", date_val):
            errors.append("'date' must be in YYYY-MM-DD format")
        else:
            try:
                datetime.strptime(date_val, "%Y-%m-%d")
            except ValueError:
                errors.append("'date' is not a valid calendar date")

    # image: must exist if provided
    img = payload.get('image')
    if img:
        if not isinstance(img, str) or not os.path.isfile(img):
            errors.append("'image' path does not exist on server")

    return (len(errors) == 0, errors)


@app.route('/api/pi-label/print', methods=['POST'])
def post_pi_label_print():
    """Trigger printing via pi-label-printer.py with provided options (JSON body)."""
    data = request.get_json(silent=True) or {}

    # Validate payload
    ok, errors = validate_payload(data)
    if not ok:
        return jsonify({'errors': errors}), 400

    # Check if we already have this template - if so, update existing instead of creating duplicate
    existing_match = _find_existing_template_match(data)
    if existing_match:
        # Update the existing template with new request, preserving the existing image
        _save_request_data(existing_match, data)
        
        # Touch the file to update its timestamp so it appears at the top of recent
        import os
        os.utime(existing_match, None)
        ts = int(existing_match.stat().st_mtime)
        preview_url = f"/preview.png?ts={ts}"
        
        return jsonify({
            'command': [],
            'returncode': 0,
            'stdout': 'Reusing existing template',
            'stderr': '',
            'elapsed_sec': 0.001,
            'preview_url': preview_url,
            'metrics': None,
            'template_reused': True
        }), 200

    cmd = build_command_from_payload(data)

    try:
        t0 = time.perf_counter()
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False,
        )
        elapsed_sec = time.perf_counter() - t0

        # Find the latest preview if generated
        preview_path = _find_latest_preview()
        preview_url = None
        if preview_path:
            ts = int(preview_path.stat().st_mtime)
            preview_url = f"/preview.png?ts={ts}"
            
            # Save request data to logs (write-once) and mirror to recent
            logs_root = _logs_dir()
            if str(preview_path).startswith(str(logs_root)):
                # Save to logs directory (the source)
                _save_request_data(preview_path, data)
                # Mirror to recent
                _mirror_request_data_to_past_images(preview_path)
            else:
                # If preview is already in recent, save there directly
                _save_request_data(preview_path, data)

        metrics = _parse_metrics_from_stdout(result.stdout) or _find_latest_metrics()

        response = {
            'command': cmd,
            'returncode': result.returncode,
            'stdout': result.stdout,
            'stderr': result.stderr,
            'elapsed_sec': round(elapsed_sec, 3),
            'preview_url': preview_url,
            'metrics': metrics,
            'template_reused': False
        }
        status = 200 if result.returncode == 0 else 500
        return jsonify(response), status
    except FileNotFoundError:
        return jsonify({'error': 'pi-label-printer.py not found', 'command': cmd}), 500
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/app', methods=['GET'])
@app.route('/app/', methods=['GET'])
def app_index():
    """Serve the index HTML that includes the print form and links."""
    return send_from_directory(os.path.join(os.path.dirname(__file__), "www"), "index.html")


@app.route('/recent', methods=['GET'])
def recent_page():
    """Serve the recent labels gallery."""
    return send_from_directory(os.path.join(os.path.dirname(__file__), "www"), "recent.html")


@app.route('/app/date', methods=['GET'])
def app_date_print():
    """Run pi-label-printer.py with default options (today's date) and show result."""
    script_path = os.path.join(os.path.dirname(__file__), 'pi-label-printer.py')
    cmd = [sys.executable or 'python3', script_path, '-o']
    try:
        t0 = time.perf_counter()
        result = subprocess.run(cmd, capture_output=True, text=True, check=False)
        elapsed_sec = time.perf_counter() - t0
        # Discover preview if available
        preview_path = _find_latest_preview()
        preview_html = ""
        if preview_path:
            ts = int(preview_path.stat().st_mtime)
            preview_html = f"<h2>Preview</h2><img src='/preview.png?ts={ts}' alt='label preview' style='border:1px solid #ddd; max-width:600px;' />"
        ok = result.returncode == 0
        status = 'OK' if ok else 'Error'
        color = '#0a7d29' if ok else '#b00020'
        body = f"""
        <!doctype html>
        <meta charset='utf-8' />
        <title>Pi Label Printer — /app/date</title>
        <style>
          body {{ font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; margin: 24px; }}
          .status {{ color: {color}; font-weight: 600; }}
          pre {{ background: #f6f8fa; padding: 12px; border-radius: 6px; }}
          a {{ color: #0366d6; text-decoration: none; }}
        </style>
        <h1>Print Today's Date</h1>
        <div class='status'>{status}: ran pi-label-printer.py (elapsed {elapsed_sec:.3f}s)</div>
        <h2>Command</h2>
        <pre>{html.escape(' '.join(cmd))}</pre>
        <h2>stdout</h2>
        <pre>{html.escape(result.stdout)}</pre>
        <h2>stderr</h2>
        <pre>{html.escape(result.stderr)}</pre>
        {preview_html}
        <p><a href='/app'>Back to index</a></p>
        """
        return Response(body, mimetype='text/html'), (200 if ok else 500)
    except FileNotFoundError:
        return Response("pi-label-printer.py not found", mimetype='text/plain'), 500
    except Exception as e:
        return Response(str(e), mimetype='text/plain'), 500


if __name__ == "__main__":
    # Simple dev server for local testing
    app.run(host="0.0.0.0", port=5000, debug=False)


# --- End of content from: server.py ---

# --- Start of content from: rw402b_ble\printer.py ---

# rw402b_ble/printer.py
# Print PIL images to Munbyn/Beeprt RW402B over BLE (TSPL) using Bleak.

import asyncio
import math
from typing import Optional, Tuple

from bleak import BleakScanner, BleakClient

# Candidate GATT characteristics seen on RW402B
WRITE_CANDIDATES = [
    "49535343-8841-43f4-a8d4-ecbe34729bb3",  # Silabs RX (write)
    "0000fff2-0000-1000-8000-00805f9b34fb",  # FFF2 (write)
]

def _looks_like_rw402b(name: Optional[str]) -> bool:
    if not name:
        return False
    n = name.lower()
    return ("rw402b" in n) or ("munbyn" in n) or ("beeprt" in n)

def _mm_to_dots(mm: float, dpi: int) -> int:
    return int(round(mm * dpi / 25.4))

def _pil_to_tspl_bitmap(img, label_w_mm: float, label_h_mm: float, dpi: int, invert: bool) -> Tuple[bytes, int, int]:
    """
    Convert a PIL.Image (any mode) to a TSPL BITMAP payload (packed 1bpp, MSB-first).
    Returns (packed_bytes, width_bytes, height_rows)
    """
    from PIL import Image

    label_w = _mm_to_dots(label_w_mm, dpi)
    label_h = _mm_to_dots(label_h_mm, dpi)

    im = img.convert("L")
    # Threshold to 1bpp: 0=black, 255=white
    im = im.point(lambda p: 0 if p < 128 else 255, mode='1')

    # Resize to label width, keep aspect
    w, h = im.size
    if w != label_w:
        new_h = int(round(h * (label_w / w)))
        im = im.resize((label_w, new_h), Image.NEAREST)

    # Clamp height to label height
    if im.height > label_h:
        im = im.crop((0, 0, im.width, label_h))

    # Pack bits MSB-first, 1 = black (RW402B needed invert=True in your tests)
    packed = bytearray()
    for y in range(im.height):
        byte = 0
        bitcount = 0
        for x in range(im.width):
            px = im.getpixel((x, y))  # 0 or 255
            bit = 1 if px == 0 else 0  # black->1, white->0
            byte = ((byte << 1) | bit) & 0xFF
            bitcount += 1
            if bitcount == 8:
                packed.append(byte)
                byte = 0
                bitcount = 0
        if bitcount:
            byte <<= (8 - bitcount)
            packed.append(byte)

    if invert:
        packed = bytes((~b) & 0xFF for b in packed)
    else:
        packed = bytes(packed)

    width_bytes = math.ceil(im.width / 8)
    height = im.height
    return packed, width_bytes, height

class RW402BPrinter:
    """
    Usage:
        p = RW402BPrinter(addr="DD:0D:30:32:20:B0")  # or leave addr=None to auto-scan
        p.print_pil_image(image, label_w_mm=57, label_h_mm=31.75, gap_mm=3)
    """

    def __init__(self, addr: Optional[str] = None, timeout: float = 4.0,
                 dpi: int = 203, invert: bool = True):
        self.addr = addr
        self.timeout = timeout
        self.dpi = dpi
        self.invert = invert
        self._write_uuid: Optional[str] = None
        self._write_resp: bool = True

    # ---------- public sync wrappers (safe to call from your app) ----------

    def print_pil_image(self, img, label_w_mm: float, label_h_mm: float, gap_mm: float = 3.0,
                        density: int = 8, speed: int = 4, direction: int = 1,
                        x: int = 0, y: int = 0, mode: int = 0):
        """Blocking wrapper."""
        return asyncio.run(self._async_print_pil_image(
            img, label_w_mm, label_h_mm, gap_mm, density, speed, direction, x, y, mode
        ))

    # ---------------------- async implementation ---------------------------

    async def _async_print_pil_image(self, img, label_w_mm: float, label_h_mm: float, gap_mm: float,
                                     density: int, speed: int, direction: int,
                                     x: int, y: int, mode: int) -> None:
        addr = self.addr or await self._scan_for_printer()
        if not addr:
            raise RuntimeError("RW402B not found during scan.")

        if not self._write_uuid:
            path = await self._choose_write_path(addr)
            if not path:
                raise RuntimeError("No writable BLE characteristic found on RW402B.")
            self._write_uuid, self._write_resp = path

        # Build TSPL and payload
        packed, wb, h = _pil_to_tspl_bitmap(img, label_w_mm, label_h_mm, self.dpi, self.invert)
        header = (
            f"SIZE {label_w_mm:.2f} mm,{label_h_mm:.2f} mm\r\n"
            f"GAP {gap_mm:.2f} mm,0\r\n"
            f"DENSITY {density}\r\n"
            f"SPEED {speed}\r\n"
            f"DIRECTION {direction}\r\n"
            "CLS\r\n"
        ).encode("ascii")
        bitcmd = f"BITMAP {x},{y},{wb},{h},{mode},".encode("ascii")
        tail = b"\r\nPRINT 1\r\n"
        blob = header + bitcmd + packed + tail

        await self._send_chunks(addr, self._write_uuid, self._write_resp, blob)

    # ----------------------------- helpers ---------------------------------

    async def _scan_for_printer(self) -> Optional[str]:
        print(f"Scanning for RW402B for {self.timeout:.1f}s…")
        devs = await BleakScanner.discover(timeout=self.timeout)
        # Choose the best by RSSI if multiple
        best = None
        best_rssi = -9999
        for d in devs:
            if _looks_like_rw402b(d.name):
                # Try to get RSSI from various places
                rssi = getattr(d, "rssi", None)
                if rssi is None and isinstance(getattr(d, "details", None), dict):
                    props = d.details.get("props") if isinstance(d.details.get("props"), dict) else None
                    if props and isinstance(props.get("RSSI"), int):
                        rssi = props["RSSI"]
                if rssi is None and getattr(d, "advertisement_data", None) is not None:
                    rssi = getattr(d.advertisement_data, "rssi", None)
                if not isinstance(rssi, int):
                    rssi = -999
                if rssi > best_rssi:
                    best = d
                    best_rssi = rssi
                print(f"  candidate: {d.address}  RSSI={rssi}  Name={d.name}")
        if best:
            print(f"Using {best.address} ({best.name})")
            return best.address
        return None

    async def _choose_write_path(self, addr: str) -> Optional[Tuple[str, bool]]:
        """Try candidates with response=True then False by doing a tiny write."""
        for uuid in WRITE_CANDIDATES:
            for resp in (True, False):
                try:
                    async with BleakClient(addr, timeout=10) as client:
                        await client.write_gatt_char(uuid, b"", response=resp)
                    print(f"Writable path OK: uuid={uuid}, response={resp}")
                    return uuid, resp
                except Exception as e:
                    print(f"Probe failed: uuid={uuid}, resp={resp}: {e}")
        return None

    async def _send_chunks(self, addr: str, uuid: str, resp: bool, blob: bytes):
        """Write in 20-byte chunks with a short delay to avoid MTU issues."""
        async with BleakClient(addr, timeout=20) as client:
            for i in range(0, len(blob), 20):
                await client.write_gatt_char(uuid, blob[i:i+20], response=resp)
                await asyncio.sleep(0.005)


# --- End of content from: rw402b_ble\printer.py ---

